From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Quim Muntal <qmuntaldiaz@microsoft.com>
Date: Mon, 23 May 2022 12:59:36 +0000
Subject: [PATCH] Vendor crypto backends

To reproduce, run 'go mod vendor' in 'go/src'.
---
 .../microsoft/go-crypto-openssl/LICENSE       |  21 +
 .../go-crypto-openssl/openssl/aes.go          | 476 ++++++++++++++
 .../go-crypto-openssl/openssl/bbig/big.go     |  38 ++
 .../go-crypto-openssl/openssl/big.go          |  13 +
 .../go-crypto-openssl/openssl/ecdh.go         | 223 +++++++
 .../go-crypto-openssl/openssl/ecdsa.go        | 174 +++++
 .../go-crypto-openssl/openssl/evpkey.go       | 325 ++++++++++
 .../go-crypto-openssl/openssl/goopenssl.c     | 153 +++++
 .../go-crypto-openssl/openssl/goopenssl.h     | 147 +++++
 .../go-crypto-openssl/openssl/hmac.go         | 251 ++++++++
 .../openssl/internal/subtle/aliasing.go       |  32 +
 .../go-crypto-openssl/openssl/openssl.go      | 302 +++++++++
 .../go-crypto-openssl/openssl/openssl_funcs.h | 293 +++++++++
 .../openssl/openssl_lock_setup.c              |  53 ++
 .../go-crypto-openssl/openssl/rand.go         |  24 +
 .../go-crypto-openssl/openssl/rsa.go          | 337 ++++++++++
 .../go-crypto-openssl/openssl/sha.go          | 600 ++++++++++++++++++
 .../microsoft/go-crypto-winnative/LICENSE     |  21 +
 .../microsoft/go-crypto-winnative/cng/aes.go  | 359 +++++++++++
 .../go-crypto-winnative/cng/bbig/big.go       |  31 +
 .../microsoft/go-crypto-winnative/cng/big.go  |  30 +
 .../microsoft/go-crypto-winnative/cng/cng.go  | 130 ++++
 .../microsoft/go-crypto-winnative/cng/ecdh.go | 260 ++++++++
 .../go-crypto-winnative/cng/ecdsa.go          | 175 +++++
 .../microsoft/go-crypto-winnative/cng/hmac.go |  55 ++
 .../microsoft/go-crypto-winnative/cng/keys.go | 161 +++++
 .../microsoft/go-crypto-winnative/cng/rand.go |  28 +
 .../microsoft/go-crypto-winnative/cng/rsa.go  | 374 +++++++++++
 .../microsoft/go-crypto-winnative/cng/sha.go  | 219 +++++++
 .../internal/bcrypt/bcrypt_windows.go         | 222 +++++++
 .../internal/bcrypt/zsyscall_windows.go       | 380 +++++++++++
 .../internal/subtle/aliasing.go               |  32 +
 .../internal/sysdll/sys_windows.go            |  55 ++
 src/vendor/modules.txt                        |  12 +
 34 files changed, 6006 insertions(+)
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/LICENSE
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/internal/subtle/aliasing.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_lock_setup.c
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rand.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/LICENSE
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/aes.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/bbig/big.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/big.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/cng.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdh.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdsa.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/hmac.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/keys.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/rand.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/rsa.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/cng/sha.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/bcrypt_windows.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/zsyscall_windows.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/internal/subtle/aliasing.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-winnative/internal/sysdll/sys_windows.go

diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/LICENSE b/src/vendor/github.com/microsoft/go-crypto-openssl/LICENSE
new file mode 100644
index 00000000000000..9e841e7a26e4eb
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/LICENSE
@@ -0,0 +1,21 @@
+    MIT License
+
+    Copyright (c) Microsoft Corporation.
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go
new file mode 100644
index 00000000000000..46d70bf26402f3
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go
@@ -0,0 +1,476 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto/cipher"
+	"errors"
+	"runtime"
+	"strconv"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-openssl/openssl/internal/subtle"
+)
+
+type aesKeySizeError int
+
+func (k aesKeySizeError) Error() string {
+	return "crypto/aes: invalid key size " + strconv.Itoa(int(k))
+}
+
+const aesBlockSize = 16
+
+type aesCipher struct {
+	key     []byte
+	enc_ctx C.GO_EVP_CIPHER_CTX_PTR
+	dec_ctx C.GO_EVP_CIPHER_CTX_PTR
+	cipher  C.GO_EVP_CIPHER_PTR
+}
+
+type extraModes interface {
+	// Copied out of crypto/aes/modes.go.
+	NewCBCEncrypter(iv []byte) cipher.BlockMode
+	NewCBCDecrypter(iv []byte) cipher.BlockMode
+	NewCTR(iv []byte) cipher.Stream
+	NewGCM(nonceSize, tagSize int) (cipher.AEAD, error)
+
+	// Invented for BoringCrypto.
+	NewGCMTLS() (cipher.AEAD, error)
+}
+
+var _ extraModes = (*aesCipher)(nil)
+
+func NewAESCipher(key []byte) (cipher.Block, error) {
+	c := &aesCipher{key: make([]byte, len(key))}
+	copy(c.key, key)
+
+	switch len(c.key) * 8 {
+	case 128:
+		c.cipher = C.go_openssl_EVP_aes_128_ecb()
+	case 192:
+		c.cipher = C.go_openssl_EVP_aes_192_ecb()
+	case 256:
+		c.cipher = C.go_openssl_EVP_aes_256_ecb()
+	default:
+		return nil, errors.New("crypto/cipher: Invalid key size")
+	}
+
+	runtime.SetFinalizer(c, (*aesCipher).finalize)
+
+	return c, nil
+}
+
+func (c *aesCipher) finalize() {
+	if c.enc_ctx != nil {
+		C.go_openssl_EVP_CIPHER_CTX_free(c.enc_ctx)
+	}
+	if c.dec_ctx != nil {
+		C.go_openssl_EVP_CIPHER_CTX_free(c.dec_ctx)
+	}
+}
+
+func (c *aesCipher) BlockSize() int { return aesBlockSize }
+
+func (c *aesCipher) Encrypt(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src) < aesBlockSize {
+		panic("crypto/aes: input not full block")
+	}
+	if len(dst) < aesBlockSize {
+		panic("crypto/aes: output not full block")
+	}
+
+	if c.enc_ctx == nil {
+		var err error
+		c.enc_ctx, err = newCipherCtx(c.cipher, C.GO_AES_ENCRYPT, c.key, nil)
+		if err != nil {
+			panic(err)
+		}
+	}
+
+	C.go_openssl_EVP_EncryptUpdate_wrapper(c.enc_ctx, base(dst), base(src), aesBlockSize)
+	runtime.KeepAlive(c)
+}
+
+func (c *aesCipher) Decrypt(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src) < aesBlockSize {
+		panic("crypto/aes: input not full block")
+	}
+	if len(dst) < aesBlockSize {
+		panic("crypto/aes: output not full block")
+	}
+	if c.dec_ctx == nil {
+		var err error
+		c.dec_ctx, err = newCipherCtx(c.cipher, C.GO_AES_DECRYPT, c.key, nil)
+		if err != nil {
+			panic(err)
+		}
+		// Disable standard block padding detection,
+		// src is always multiple of the block size.
+		if C.go_openssl_EVP_CIPHER_CTX_set_padding(c.dec_ctx, 0) != 1 {
+			panic("crypto/cipher: unable to set padding")
+		}
+	}
+	C.go_openssl_EVP_DecryptUpdate_wrapper(c.dec_ctx, base(dst), base(src), aesBlockSize)
+	runtime.KeepAlive(c)
+}
+
+type aesCBC struct {
+	ctx C.GO_EVP_CIPHER_CTX_PTR
+}
+
+func (x *aesCBC) BlockSize() int { return aesBlockSize }
+
+func (x *aesCBC) CryptBlocks(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src)%aesBlockSize != 0 {
+		panic("crypto/cipher: input not full blocks")
+	}
+	if len(dst) < len(src) {
+		panic("crypto/cipher: output smaller than input")
+	}
+	if len(src) > 0 {
+		if C.go_openssl_EVP_CipherUpdate_wrapper(x.ctx, base(dst), base(src), C.int(len(src))) != 1 {
+			panic("crypto/cipher: CipherUpdate failed")
+		}
+		runtime.KeepAlive(x)
+	}
+}
+
+func (x *aesCBC) SetIV(iv []byte) {
+	if len(iv) != aesBlockSize {
+		panic("cipher: incorrect length IV")
+	}
+	if C.go_openssl_EVP_CipherInit_ex(x.ctx, nil, nil, nil, base(iv), -1) != 1 {
+		panic("cipher: unable to initialize EVP cipher ctx")
+	}
+}
+
+func (c *aesCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
+	x := new(aesCBC)
+
+	var cipher C.GO_EVP_CIPHER_PTR
+	switch len(c.key) * 8 {
+	case 128:
+		cipher = C.go_openssl_EVP_aes_128_cbc()
+	case 192:
+		cipher = C.go_openssl_EVP_aes_192_cbc()
+	case 256:
+		cipher = C.go_openssl_EVP_aes_256_cbc()
+	default:
+		panic("openssl: unsupported key length")
+	}
+	var err error
+	x.ctx, err = newCipherCtx(cipher, C.GO_AES_ENCRYPT, c.key, iv)
+	if err != nil {
+		panic(err)
+	}
+
+	runtime.SetFinalizer(x, (*aesCBC).finalize)
+
+	return x
+}
+
+func (c *aesCBC) finalize() {
+	C.go_openssl_EVP_CIPHER_CTX_free(c.ctx)
+}
+
+func (c *aesCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
+	x := new(aesCBC)
+
+	var cipher C.GO_EVP_CIPHER_PTR
+	switch len(c.key) * 8 {
+	case 128:
+		cipher = C.go_openssl_EVP_aes_128_cbc()
+	case 192:
+		cipher = C.go_openssl_EVP_aes_192_cbc()
+	case 256:
+		cipher = C.go_openssl_EVP_aes_256_cbc()
+	default:
+		panic("openssl: unsupported key length")
+	}
+
+	var err error
+	x.ctx, err = newCipherCtx(cipher, C.GO_AES_DECRYPT, c.key, iv)
+	if err != nil {
+		panic(err)
+	}
+	if C.go_openssl_EVP_CIPHER_CTX_set_padding(x.ctx, 0) != 1 {
+		panic("cipher: unable to set padding")
+	}
+
+	runtime.SetFinalizer(x, (*aesCBC).finalize)
+	return x
+}
+
+type aesCTR struct {
+	ctx C.GO_EVP_CIPHER_CTX_PTR
+}
+
+func (x *aesCTR) XORKeyStream(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(dst) < len(src) {
+		panic("crypto/cipher: output smaller than input")
+	}
+	if len(src) == 0 {
+		return
+	}
+	C.go_openssl_EVP_EncryptUpdate_wrapper(x.ctx, base(dst), base(src), C.int(len(src)))
+	runtime.KeepAlive(x)
+}
+
+func (c *aesCipher) NewCTR(iv []byte) cipher.Stream {
+	x := new(aesCTR)
+
+	var cipher C.GO_EVP_CIPHER_PTR
+	switch len(c.key) * 8 {
+	case 128:
+		cipher = C.go_openssl_EVP_aes_128_ctr()
+	case 192:
+		cipher = C.go_openssl_EVP_aes_192_ctr()
+	case 256:
+		cipher = C.go_openssl_EVP_aes_256_ctr()
+	default:
+		panic("openssl: unsupported key length")
+	}
+	var err error
+	x.ctx, err = newCipherCtx(cipher, C.GO_AES_ENCRYPT, c.key, iv)
+	if err != nil {
+		panic(err)
+	}
+
+	runtime.SetFinalizer(x, (*aesCTR).finalize)
+
+	return x
+}
+
+func (c *aesCTR) finalize() {
+	C.go_openssl_EVP_CIPHER_CTX_free(c.ctx)
+}
+
+type aesGCM struct {
+	ctx          C.GO_EVP_CIPHER_CTX_PTR
+	tls          bool
+	minNextNonce uint64
+}
+
+const (
+	gcmTagSize           = 16
+	gcmStandardNonceSize = 12
+	gcmTlsAddSize        = 13
+	gcmTlsFixedNonceSize = 4
+)
+
+type aesNonceSizeError int
+
+func (n aesNonceSizeError) Error() string {
+	return "crypto/aes: invalid GCM nonce size " + strconv.Itoa(int(n))
+}
+
+type noGCM struct {
+	cipher.Block
+}
+
+func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
+	if nonceSize != gcmStandardNonceSize && tagSize != gcmTagSize {
+		return nil, errors.New("crypto/aes: GCM tag and nonce sizes can't be non-standard at the same time")
+	}
+	// Fall back to standard library for GCM with non-standard nonce or tag size.
+	if nonceSize != gcmStandardNonceSize {
+		return cipher.NewGCMWithNonceSize(&noGCM{c}, nonceSize)
+	}
+	if tagSize != gcmTagSize {
+		return cipher.NewGCMWithTagSize(&noGCM{c}, tagSize)
+	}
+	return c.newGCM(false)
+}
+
+// NewGCMTLS returns a GCM cipher specific to TLS
+// and should not be used for non-TLS purposes.
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
+	return c.(*aesCipher).NewGCMTLS()
+}
+
+func (c *aesCipher) NewGCMTLS() (cipher.AEAD, error) {
+	return c.newGCM(true)
+}
+
+func (c *aesCipher) newGCM(tls bool) (cipher.AEAD, error) {
+	var cipher C.GO_EVP_CIPHER_PTR
+	switch len(c.key) * 8 {
+	case 128:
+		cipher = C.go_openssl_EVP_aes_128_gcm()
+	case 192:
+		cipher = C.go_openssl_EVP_aes_192_gcm()
+	case 256:
+		cipher = C.go_openssl_EVP_aes_256_gcm()
+	default:
+		panic("openssl: unsupported key length")
+	}
+	ctx, err := newCipherCtx(cipher, -1, c.key, nil)
+	if err != nil {
+		return nil, err
+	}
+	g := &aesGCM{ctx: ctx, tls: tls}
+	runtime.SetFinalizer(g, (*aesGCM).finalize)
+	return g, nil
+}
+
+func (g *aesGCM) finalize() {
+	C.go_openssl_EVP_CIPHER_CTX_free(g.ctx)
+}
+
+func (g *aesGCM) NonceSize() int {
+	return gcmStandardNonceSize
+}
+
+func (g *aesGCM) Overhead() int {
+	return gcmTagSize
+}
+
+// base returns the address of the underlying array in b,
+// being careful not to panic when b has zero length.
+func base(b []byte) *C.uchar {
+	if len(b) == 0 {
+		return nil
+	}
+	return (*C.uchar)(unsafe.Pointer(&b[0]))
+}
+
+func (g *aesGCM) Seal(dst, nonce, plaintext, additionalData []byte) []byte {
+	if len(nonce) != gcmStandardNonceSize {
+		panic("cipher: incorrect nonce length given to GCM")
+	}
+	if uint64(len(plaintext)) > ((1<<32)-2)*aesBlockSize || len(plaintext)+gcmTagSize < len(plaintext) {
+		panic("cipher: message too large for GCM")
+	}
+	if len(dst)+len(plaintext)+gcmTagSize < len(dst) {
+		panic("cipher: message too large for buffer")
+	}
+	if g.tls {
+		if len(additionalData) != gcmTlsAddSize {
+			panic("cipher: incorrect additional data length given to GCM TLS")
+		}
+		// BoringCrypto enforces strictly monotonically increasing explicit nonces
+		// and to fail after 2^64 - 1 keys as per FIPS 140-2 IG A.5,
+		// but OpenSSL does not perform this check, so it is implemented here.
+		const maxUint64 = 1<<64 - 1
+		counter := bigUint64(nonce[gcmTlsFixedNonceSize:])
+		if counter == maxUint64 {
+			panic("cipher: nonce counter must be less than 2^64 - 1")
+		}
+		if counter < g.minNextNonce {
+			panic("cipher: nonce counter must be strictly monotonically increasing")
+		}
+		defer func() {
+			g.minNextNonce = counter + 1
+		}()
+	}
+
+	// Make room in dst to append plaintext+overhead.
+	ret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)
+
+	// Check delayed until now to make sure len(dst) is accurate.
+	if subtle.InexactOverlap(out, plaintext) {
+		panic("cipher: invalid buffer overlap")
+	}
+
+	// Encrypt additional data.
+	// When sealing a TLS payload, OpenSSL app sets the additional data using
+	// 'EVP_CIPHER_CTX_ctrl(g.ctx, C.EVP_CTRL_AEAD_TLS1_AAD, C.EVP_AEAD_TLS1_AAD_LEN, base(additionalData))'.
+	// This makes the explicit nonce component to monotonically increase on every Seal operation without
+	// relying in the explicit nonce being securely set externally,
+	// and it also gives some interesting speed gains.
+	// Unfortunately we can't use it because Go expects AEAD.Seal to honor the provided nonce.
+	if C.go_openssl_EVP_CIPHER_CTX_seal_wrapper(g.ctx, base(out), base(nonce),
+		base(plaintext), C.int(len(plaintext)),
+		base(additionalData), C.int(len(additionalData))) != 1 {
+
+		panic(fail("EVP_CIPHER_CTX_seal"))
+	}
+	runtime.KeepAlive(g)
+	return ret
+}
+
+var errOpen = errors.New("cipher: message authentication failed")
+
+func (g *aesGCM) Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) {
+	if len(nonce) != gcmStandardNonceSize {
+		panic("cipher: incorrect nonce length given to GCM")
+	}
+	if len(ciphertext) < gcmTagSize {
+		return nil, errOpen
+	}
+	if uint64(len(ciphertext)) > ((1<<32)-2)*aesBlockSize+gcmTagSize {
+		return nil, errOpen
+	}
+	// BoringCrypto does not do any TLS check when decrypting, neither do we.
+
+	tag := ciphertext[len(ciphertext)-gcmTagSize:]
+	ciphertext = ciphertext[:len(ciphertext)-gcmTagSize]
+
+	// Make room in dst to append ciphertext without tag.
+	ret, out := sliceForAppend(dst, len(ciphertext))
+
+	// Check delayed until now to make sure len(dst) is accurate.
+	if subtle.InexactOverlap(out, ciphertext) {
+		panic("cipher: invalid buffer overlap")
+	}
+
+	if C.go_openssl_EVP_CIPHER_CTX_open_wrapper(g.ctx, base(out), base(nonce),
+		base(ciphertext), C.int(len(ciphertext)),
+		base(additionalData), C.int(len(additionalData)), base(tag)) != 1 {
+
+		for i := range out {
+			out[i] = 0
+		}
+		return nil, errOpen
+	}
+	runtime.KeepAlive(g)
+	return ret, nil
+}
+
+// sliceForAppend is a mirror of crypto/cipher.sliceForAppend.
+func sliceForAppend(in []byte, n int) (head, tail []byte) {
+	if total := len(in) + n; cap(in) >= total {
+		head = in[:total]
+	} else {
+		head = make([]byte, total)
+		copy(head, in)
+	}
+	tail = head[len(in):]
+	return
+}
+
+func newCipherCtx(cipher C.GO_EVP_CIPHER_PTR, mode C.int, key, iv []byte) (C.GO_EVP_CIPHER_CTX_PTR, error) {
+	ctx := C.go_openssl_EVP_CIPHER_CTX_new()
+	if ctx == nil {
+		return nil, fail("unable to create EVP cipher ctx")
+	}
+	if C.go_openssl_EVP_CipherInit_ex(ctx, cipher, nil, base(key), base(iv), mode) != 1 {
+		C.go_openssl_EVP_CIPHER_CTX_free(ctx)
+		return nil, fail("unable to initialize EVP cipher ctx")
+	}
+	return ctx, nil
+}
+
+func bigUint64(b []byte) uint64 {
+	_ = b[7] // bounds check hint to compiler; see go.dev/issue/14808
+	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
+		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go
new file mode 100644
index 00000000000000..1214e1097ef56d
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go
@@ -0,0 +1,38 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This is a mirror of crypto/internal/boring/bbig/big.go.
+
+package bbig
+
+import (
+	"math/big"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-openssl/openssl"
+)
+
+func Enc(b *big.Int) openssl.BigInt {
+	if b == nil {
+		return nil
+	}
+	x := b.Bits()
+	if len(x) == 0 {
+		return openssl.BigInt{}
+	}
+	// TODO: Use unsafe.Slice((*uint)(&x[0]), len(x)) once go1.16 is no longer supported.
+	return (*(*[]uint)(unsafe.Pointer(&x)))[:len(x)]
+}
+
+func Dec(b openssl.BigInt) *big.Int {
+	if b == nil {
+		return nil
+	}
+	if len(b) == 0 {
+		return new(big.Int)
+	}
+	// TODO: Use unsafe.Slice((*uint)(&b[0]), len(b)) once go1.16 is no longer supported.
+	x := (*(*[]big.Word)(unsafe.Pointer(&b)))[:len(b)]
+	return new(big.Int).SetBits(x)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go
new file mode 100644
index 00000000000000..7207bde01c9d94
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go
@@ -0,0 +1,13 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+package openssl
+
+// This file does not have build constraints to
+// facilitate using BigInt in Go crypto.
+// Go crypto references BigInt unconditionally,
+// even if it is not finally used.
+
+// A BigInt is the raw words from a BigInt.
+// This definition allows us to avoid importing math/big.
+// Conversion between BigInt and *big.Int is in openssl/bbig.
+type BigInt []uint
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go
new file mode 100644
index 00000000000000..fba3704531eda6
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go
@@ -0,0 +1,223 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"runtime"
+)
+
+type PublicKeyECDH struct {
+	_pkey C.GO_EVP_PKEY_PTR
+	bytes []byte
+
+	// priv is only set when PublicKeyECDH is derived from a private key,
+	// in which case priv's finalizer is responsible for freeing _pkey.
+	// This ensures priv is not finalized while the public key is alive,
+	// which could cause use-after-free and double-free behavior.
+	//
+	// We could avoid this altogether if using EVP_PKEY_up_ref
+	// when instantiating a derived public key, unfortunately
+	// it is not available on OpenSSL 1.0.2.
+	priv *PrivateKeyECDH
+}
+
+func (k *PublicKeyECDH) finalize() {
+	if k.priv == nil {
+		C.go_openssl_EVP_PKEY_free(k._pkey)
+	}
+}
+
+type PrivateKeyECDH struct {
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PrivateKeyECDH) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*PublicKeyECDH, error) {
+	if len(bytes) < 1 {
+		return nil, errors.New("NewPublicKeyECDH: missing key")
+	}
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name")
+	}
+	var k *PublicKeyECDH
+	defer func() {
+		if k == nil {
+			C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if vMajor == 1 && vMinor == 0 {
+		// EC_KEY_oct2key does not exist on OpenSSL 1.0.2,
+		// we have to simulate it.
+		group := C.go_openssl_EC_KEY_get0_group(key)
+		pt := C.go_openssl_EC_POINT_new(group)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		defer C.go_openssl_EC_POINT_free(pt)
+		if C.go_openssl_EC_POINT_oct2point(group, pt, base(bytes), C.size_t(len(bytes)), nil) != 1 {
+			return nil, errors.New("point not on curve")
+		}
+		if C.go_openssl_EC_KEY_set_public_key(key, pt) != 1 {
+			return nil, newOpenSSLError("EC_KEY_set_public_key")
+		}
+	} else {
+		if C.go_openssl_EC_KEY_oct2key(key, base(bytes), C.size_t(len(bytes)), nil) != 1 {
+			return nil, newOpenSSLError("EC_KEY_oct2key")
+		}
+	}
+	pkey, err := newEVPPKEY(key)
+	if err != nil {
+		return nil, err
+	}
+	k = &PublicKeyECDH{pkey, append([]byte(nil), bytes...), nil}
+	runtime.SetFinalizer(k, (*PublicKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyECDH) Bytes() []byte { return k.bytes }
+
+func NewPrivateKeyECDH(curve string, bytes []byte) (*PrivateKeyECDH, error) {
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	b := bytesToBN(bytes)
+	if b == nil {
+		return nil, newOpenSSLError("BN_bin2bn")
+	}
+	defer C.go_openssl_BN_free(b)
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name")
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	defer func() {
+		if pkey == nil {
+			C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if C.go_openssl_EC_KEY_set_private_key(key, b) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_private_key")
+	}
+	pkey, err = newEVPPKEY(key)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDH{pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) {
+	defer runtime.KeepAlive(k)
+	key := C.go_openssl_EVP_PKEY_get1_EC_KEY(k._pkey)
+	if key == nil {
+		return nil, newOpenSSLError("EVP_PKEY_get1_EC_KEY")
+	}
+	defer C.go_openssl_EC_KEY_free(key)
+	group := C.go_openssl_EC_KEY_get0_group(key)
+	if group == nil {
+		return nil, newOpenSSLError("EC_KEY_get0_group")
+	}
+	pt := C.go_openssl_EC_KEY_get0_public_key(key)
+	if pt == nil {
+		// The public key will be nil if k has been generated using
+		// NewPrivateKeyECDH instead of GenerateKeyECDH.
+		//
+		// OpenSSL does not expose any method to generate the public
+		// key from the private key [1], so we have to calculate it here
+		// https://github.com/openssl/openssl/issues/18437#issuecomment-1144717206
+		pt = C.go_openssl_EC_POINT_new(group)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		defer C.go_openssl_EC_POINT_free(pt)
+		kbig := C.go_openssl_EC_KEY_get0_private_key(key)
+		if C.go_openssl_EC_POINT_mul(group, pt, kbig, nil, nil, nil) == 0 {
+			return nil, newOpenSSLError("EC_POINT_mul")
+		}
+	}
+	n := C.go_openssl_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, nil, 0, nil)
+	if n == 0 {
+		return nil, newOpenSSLError("EC_POINT_point2oct")
+	}
+	bytes := make([]byte, n)
+	n = C.go_openssl_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, base(bytes), C.size_t(len(bytes)), nil)
+	if int(n) != len(bytes) {
+		return nil, newOpenSSLError("EC_POINT_point2oct")
+	}
+	pub := &PublicKeyECDH{k._pkey, bytes, k}
+	// Note: Same as in NewPublicKeyECDH regarding finalizer and KeepAlive.
+	runtime.SetFinalizer(pub, (*PublicKeyECDH).finalize)
+	return pub, nil
+}
+
+func ECDH(priv *PrivateKeyECDH, pub *PublicKeyECDH) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	defer runtime.KeepAlive(pub)
+	ctx := C.go_openssl_EVP_PKEY_CTX_new(priv._pkey, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new")
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	if C.go_openssl_EVP_PKEY_derive_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	if C.go_openssl_EVP_PKEY_derive_set_peer(ctx, pub._pkey) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_set_peer")
+	}
+	var outLen C.size_t
+	if C.go_openssl_EVP_PKEY_derive(ctx, nil, &outLen) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	out := make([]byte, outLen)
+	if C.go_openssl_EVP_PKEY_derive(ctx, base(out), &outLen) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	return out, nil
+}
+
+func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_EC, 0, curve)
+	if err != nil {
+		return nil, nil, err
+	}
+	var k *PrivateKeyECDH
+	defer func() {
+		if k == nil {
+			C.go_openssl_EVP_PKEY_free(pkey)
+		}
+	}()
+	key := C.go_openssl_EVP_PKEY_get1_EC_KEY(pkey)
+	if key == nil {
+		return nil, nil, newOpenSSLError("EVP_PKEY_get1_EC_KEY")
+	}
+	defer C.go_openssl_EC_KEY_free(key)
+	b := C.go_openssl_EC_KEY_get0_private_key(key)
+	if b == nil {
+		return nil, nil, newOpenSSLError("EC_KEY_get0_private_key")
+	}
+	bits := C.go_openssl_EVP_PKEY_get_bits(pkey)
+	out := make([]byte, (bits+7)/8)
+	if C.go_openssl_BN_bn2binpad(b, base(out), C.int(len(out))) == 0 {
+		return nil, nil, newOpenSSLError("BN_bn2binpad")
+	}
+	k = &PrivateKeyECDH{pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, out, nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go
new file mode 100644
index 00000000000000..de4aa0ecfcbcab
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go
@@ -0,0 +1,174 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"runtime"
+)
+
+type PrivateKeyECDSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PrivateKeyECDSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PrivateKeyECDSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+type PublicKeyECDSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PublicKeyECDSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PublicKeyECDSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+var errUnknownCurve = errors.New("openssl: unknown elliptic curve")
+var errUnsupportedCurve = errors.New("openssl: unsupported elliptic curve")
+
+func curveNID(curve string) (C.int, error) {
+	switch curve {
+	case "P-224":
+		return C.GO_NID_secp224r1, nil
+	case "P-256":
+		return C.GO_NID_X9_62_prime256v1, nil
+	case "P-384":
+		return C.GO_NID_secp384r1, nil
+	case "P-521":
+		return C.GO_NID_secp521r1, nil
+	}
+	return 0, errUnknownCurve
+}
+
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	pkey, err := newECKey(curve, X, Y, nil)
+	if err != nil {
+		return nil, err
+	}
+	k := &PublicKeyECDSA{_pkey: pkey}
+	// Note: Because of the finalizer, any time k.key is passed to cgo,
+	// that call must be followed by a call to runtime.KeepAlive(k),
+	// to make sure k is not collected (and finalized) before the cgo
+	// call returns.
+	runtime.SetFinalizer(k, (*PublicKeyECDSA).finalize)
+	return k, nil
+}
+
+func newECKey(curve string, X, Y, D BigInt) (C.GO_EVP_PKEY_PTR, error) {
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	var bx, by, bd C.GO_BIGNUM_PTR
+	defer func() {
+		if bx != nil {
+			C.go_openssl_BN_free(bx)
+		}
+		if by != nil {
+			C.go_openssl_BN_free(by)
+		}
+		if bd != nil {
+			C.go_openssl_BN_free(bd)
+		}
+	}()
+	bx = bigToBN(X)
+	by = bigToBN(Y)
+	bd = bigToBN(D)
+	if bx == nil || by == nil || (D != nil && bd == nil) {
+		return nil, newOpenSSLError("BN_lebin2bn failed")
+	}
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name failed")
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	defer func() {
+		if pkey == nil {
+			defer C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if C.go_openssl_EC_KEY_set_public_key_affine_coordinates(key, bx, by) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_public_key_affine_coordinates failed")
+	}
+	if D != nil && C.go_openssl_EC_KEY_set_private_key(key, bd) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_private_key failed")
+	}
+	pkey, err = newEVPPKEY(key)
+	if err != nil {
+		return nil, err
+	}
+	return pkey, nil
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	pkey, err := newECKey(curve, X, Y, D)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDSA{_pkey: pkey}
+	// Note: Because of the finalizer, any time k.key is passed to cgo,
+	// that call must be followed by a call to runtime.KeepAlive(k),
+	// to make sure k is not collected (and finalized) before the cgo
+	// call returns.
+	runtime.SetFinalizer(k, (*PrivateKeyECDSA).finalize)
+	return k, nil
+}
+
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	return evpSign(priv.withKey, 0, 0, 0, hash)
+}
+
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	return evpVerify(pub.withKey, 0, 0, 0, sig, hash) == nil
+}
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_EC, 0, curve)
+	if err != nil {
+		return nil, nil, nil, err
+	}
+	defer C.go_openssl_EVP_PKEY_free(pkey)
+	key := C.go_openssl_EVP_PKEY_get1_EC_KEY(pkey)
+	if key == nil {
+		return nil, nil, nil, newOpenSSLError("EVP_PKEY_get1_EC_KEY failed")
+	}
+	defer C.go_openssl_EC_KEY_free(key)
+	group := C.go_openssl_EC_KEY_get0_group(key)
+	pt := C.go_openssl_EC_KEY_get0_public_key(key)
+	bd := C.go_openssl_EC_KEY_get0_private_key(key)
+	if pt == nil || bd == nil {
+		return nil, nil, nil, newOpenSSLError("EC_KEY_get0_private_key failed")
+	}
+	bx := C.go_openssl_BN_new()
+	if bx == nil {
+		return nil, nil, nil, newOpenSSLError("BN_new failed")
+	}
+	defer C.go_openssl_BN_free(bx)
+	by := C.go_openssl_BN_new()
+	if by == nil {
+		return nil, nil, nil, newOpenSSLError("BN_new failed")
+	}
+	defer C.go_openssl_BN_free(by)
+	if C.go_openssl_EC_POINT_get_affine_coordinates_GFp(group, pt, bx, by, nil) == 0 {
+		return nil, nil, nil, newOpenSSLError("EC_POINT_get_affine_coordinates_GFp failed")
+	}
+	return bnToBig(bx), bnToBig(by), bnToBig(bd), nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go
new file mode 100644
index 00000000000000..2965d017dda95c
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go
@@ -0,0 +1,325 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"errors"
+	"hash"
+	"unsafe"
+)
+
+// hashToMD converts a hash.Hash implementation from this package to a GO_EVP_MD_PTR.
+func hashToMD(h hash.Hash) C.GO_EVP_MD_PTR {
+	switch h.(type) {
+	case *sha1Hash:
+		return C.go_openssl_EVP_sha1()
+	case *sha224Hash:
+		return C.go_openssl_EVP_sha224()
+	case *sha256Hash:
+		return C.go_openssl_EVP_sha256()
+	case *sha384Hash:
+		return C.go_openssl_EVP_sha384()
+	case *sha512Hash:
+		return C.go_openssl_EVP_sha512()
+	}
+	return nil
+}
+
+// cryptoHashToMD converts a crypto.Hash to a GO_EVP_MD_PTR.
+func cryptoHashToMD(ch crypto.Hash) C.GO_EVP_MD_PTR {
+	switch ch {
+	case crypto.MD5:
+		return C.go_openssl_EVP_md5()
+	case crypto.MD5SHA1:
+		if vMajor == 1 && vMinor == 0 {
+			// MD5SHA1 is not implemented in OpenSSL 1.0.2.
+			// It is implemented in higher versions but without FIPS support.
+			// It is considered a deprecated digest, not approved by FIPS 140-2
+			// and only used in pre-TLS 1.2, so we would rather not support it
+			// if using 1.0.2 than than implement something that is not properly validated.
+			return nil
+		}
+		return C.go_openssl_EVP_md5_sha1()
+	case crypto.SHA1:
+		return C.go_openssl_EVP_sha1()
+	case crypto.SHA224:
+		return C.go_openssl_EVP_sha224()
+	case crypto.SHA256:
+		return C.go_openssl_EVP_sha256()
+	case crypto.SHA384:
+		return C.go_openssl_EVP_sha384()
+	case crypto.SHA512:
+		return C.go_openssl_EVP_sha512()
+	}
+	return nil
+}
+
+func generateEVPPKey(id C.int, bits int, curve string) (C.GO_EVP_PKEY_PTR, error) {
+	if (bits == 0 && curve == "") || (bits != 0 && curve != "") {
+		return nil, fail("incorrect generateEVPPKey parameters")
+	}
+	ctx := C.go_openssl_EVP_PKEY_CTX_new_id(id, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new_id failed")
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	if C.go_openssl_EVP_PKEY_keygen_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_keygen_init failed")
+	}
+	if bits != 0 {
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, id, -1, C.GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS, C.int(bits), nil) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+	}
+	if curve != "" {
+		nid, err := curveNID(curve)
+		if err != nil {
+			return nil, err
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, id, -1, C.GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, nil) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	if C.go_openssl_EVP_PKEY_keygen(ctx, &pkey) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_keygen failed")
+	}
+	return pkey, nil
+}
+
+type withKeyFunc func(func(C.GO_EVP_PKEY_PTR) C.int) C.int
+type initFunc func(C.GO_EVP_PKEY_CTX_PTR) error
+type cryptFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, *C.size_t, *C.uchar, C.size_t) error
+type verifyFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, C.size_t, *C.uchar, C.size_t) error
+
+func setupEVP(withKey withKeyFunc, padding C.int,
+	h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
+	init initFunc) (ctx C.GO_EVP_PKEY_CTX_PTR, err error) {
+	defer func() {
+		if err != nil {
+			if ctx != nil {
+				C.go_openssl_EVP_PKEY_CTX_free(ctx)
+				ctx = nil
+			}
+		}
+	}()
+
+	withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {
+		ctx = C.go_openssl_EVP_PKEY_CTX_new(pkey, nil)
+		return 1
+	})
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new failed")
+	}
+	if err := init(ctx); err != nil {
+		return nil, err
+	}
+	if padding == 0 {
+		return ctx, nil
+	}
+	// Each padding type has its own requirements in terms of when to apply the padding,
+	// so it can't be just set at this point.
+	setPadding := func() error {
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PADDING, padding, nil) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+		return nil
+	}
+	switch padding {
+	case C.GO_RSA_PKCS1_OAEP_PADDING:
+		md := hashToMD(h)
+		if md == nil {
+			return nil, errors.New("crypto/rsa: unsupported hash function")
+		}
+		var mgfMD C.GO_EVP_MD_PTR
+		if mgfHash != nil {
+			// mgfHash is optional, but if it is set it must match a supported hash function.
+			mgfMD = hashToMD(mgfHash)
+			if mgfMD == nil {
+				return nil, errors.New("crypto/rsa: unsupported hash function")
+			}
+		}
+		// setPadding must happen before setting EVP_PKEY_CTRL_RSA_OAEP_MD.
+		if err := setPadding(); err != nil {
+			return nil, err
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_MD, 0, unsafe.Pointer(md)) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+		if mgfHash != nil {
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_MGF1_MD, 0, unsafe.Pointer(mgfMD)) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+		}
+		// ctx takes ownership of label, so malloc a copy for OpenSSL to free.
+		// OpenSSL 1.1.1 and higher does not take ownership of the label if the length is zero,
+		// so better avoid the allocation.
+		var clabel *C.uchar
+		if len(label) > 0 {
+			// Go guarantees C.malloc never returns nil.
+			clabel = (*C.uchar)(C.malloc(C.size_t(len(label))))
+			copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL, C.int(len(label)), unsafe.Pointer(clabel)) != 1 {
+			if clabel != nil {
+				C.free(unsafe.Pointer(clabel))
+			}
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+	case C.GO_RSA_PKCS1_PSS_PADDING:
+		md := cryptoHashToMD(ch)
+		if md == nil {
+			return nil, errors.New("crypto/rsa: unsupported hash function")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_MD, 0, unsafe.Pointer(md)) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+		// setPadding must happen after setting EVP_PKEY_CTRL_MD.
+		if err := setPadding(); err != nil {
+			return nil, err
+		}
+		if saltLen != 0 {
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN, saltLen, nil) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+		}
+
+	case C.GO_RSA_PKCS1_PADDING:
+		if ch != 0 {
+			// We support unhashed messages.
+			md := cryptoHashToMD(ch)
+			if md == nil {
+				return nil, errors.New("crypto/rsa: unsupported hash function")
+			}
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1, -1, C.GO_EVP_PKEY_CTRL_MD, 0, unsafe.Pointer(md)) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+			if err := setPadding(); err != nil {
+				return nil, err
+			}
+		}
+	default:
+		if err := setPadding(); err != nil {
+			return nil, err
+		}
+	}
+	return ctx, nil
+}
+
+func cryptEVP(withKey withKeyFunc, padding C.int,
+	h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
+	init initFunc, crypt cryptFunc, in []byte) ([]byte, error) {
+
+	ctx, err := setupEVP(withKey, padding, h, mgfHash, label, saltLen, ch, init)
+	if err != nil {
+		return nil, err
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	pkeySize := withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {
+		return C.go_openssl_EVP_PKEY_get_size(pkey)
+	})
+	outLen := C.size_t(pkeySize)
+	out := make([]byte, pkeySize)
+	if err := crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))); err != nil {
+		return nil, err
+	}
+	// The size returned by EVP_PKEY_get_size() is only preliminary and not exact,
+	// so the final contents of the out buffer may be smaller.
+	return out[:outLen], nil
+}
+
+func verifyEVP(withKey withKeyFunc, padding C.int,
+	h hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
+	init initFunc, verify verifyFunc,
+	sig, in []byte) error {
+
+	ctx, err := setupEVP(withKey, padding, h, nil, label, saltLen, ch, init)
+	if err != nil {
+		return err
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	return verify(ctx, base(sig), C.size_t(len(sig)), base(in), C.size_t(len(in)))
+}
+
+func evpEncrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {
+	encryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_encrypt_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_encrypt_init failed")
+		}
+		return nil
+	}
+	encrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_encrypt failed")
+		}
+		return nil
+	}
+	return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, encryptInit, encrypt, msg)
+}
+
+func evpDecrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {
+	decryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_decrypt_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_decrypt_init failed")
+		}
+		return nil
+	}
+	decrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_decrypt failed")
+		}
+		return nil
+	}
+	return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, decryptInit, decrypt, msg)
+}
+
+func evpSign(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, hashed []byte) ([]byte, error) {
+	signtInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_sign_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_sign_init failed")
+		}
+		return nil
+	}
+	sign := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_sign(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_sign failed")
+		}
+		return nil
+	}
+	return cryptEVP(withKey, padding, nil, nil, nil, saltLen, h, signtInit, sign, hashed)
+}
+
+func evpVerify(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, sig, hashed []byte) error {
+	verifyInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_verify_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_verify_init failed")
+		}
+		return nil
+	}
+	verify := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_verify(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_verify failed")
+		}
+		return nil
+	}
+	return verifyEVP(withKey, padding, nil, nil, saltLen, h, verifyInit, verify, sig, hashed)
+}
+
+func newEVPPKEY(key C.GO_EC_KEY_PTR) (C.GO_EVP_PKEY_PTR, error) {
+	pkey := C.go_openssl_EVP_PKEY_new()
+	if pkey == nil {
+		return nil, newOpenSSLError("EVP_PKEY_new failed")
+	}
+	if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_EC, (unsafe.Pointer)(key)) != 1 {
+		C.go_openssl_EVP_PKEY_free(pkey)
+		return nil, newOpenSSLError("EVP_PKEY_assign failed")
+	}
+	return pkey, nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c
new file mode 100644
index 00000000000000..7bbf74185128dd
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c
@@ -0,0 +1,153 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+#include "goopenssl.h"
+
+#include <dlfcn.h>
+#include <stdio.h>
+
+static unsigned long
+version_num(void* handle)
+{
+    unsigned long (*fn)(void);
+    // OPENSSL_version_num is defined in OpenSSL 1.1.0 and 1.1.1.
+    fn = (unsigned long (*)(void))dlsym(handle, "OpenSSL_version_num");
+    if (fn != NULL)
+        return fn();
+
+    // SSLeay is defined in OpenSSL 1.0.2.
+    fn = (unsigned long (*)(void))dlsym(handle, "SSLeay");
+    if (fn != NULL)
+        return fn();
+
+    return 0;
+} 
+
+int
+go_openssl_version_major(void* handle)
+{
+    unsigned int (*fn)(void);
+    // OPENSSL_version_major is supported since OpenSSL 3.
+    fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_major");
+    if (fn != NULL)
+        return (int)fn();
+
+    // If OPENSSL_version_major is not defined, try with OpenSSL 1 functions.
+    unsigned long num = version_num(handle);
+    if (num < 0x10000000L || num >= 0x20000000L)
+        return -1;
+
+    return 1;
+}
+
+int
+go_openssl_version_minor(void* handle)
+{
+    unsigned int (*fn)(void);
+    // OPENSSL_version_major is supported since OpenSSL 3.
+    fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_minor");
+    if (fn != NULL)
+        return (int)fn();
+
+    // If OPENSSL_version_major is not defined, try with OpenSSL 1 functions.
+    unsigned long num = version_num(handle);
+    // OpenSSL version number follows this schema:
+    // MNNFFPPS: major minor fix patch status.
+    if (num < 0x10000000L || num >= 0x10200000L)
+    {
+        // We only support minor version 0 and 1,
+        // so there is no need to implement an algorithm
+        // that decodes the version number into individual components.
+        return -1;
+    }
+
+    if (num >= 0x10100000L)
+        return 1;
+    
+    return 0;
+}
+
+// Approach taken from .Net System.Security.Cryptography.Native
+// https://github.com/dotnet/runtime/blob/f64246ce08fb7a58221b2b7c8e68f69c02522b0d/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.c
+
+#define DEFINEFUNC(ret, func, args, argscall)                  ret (*_g_##func)args; 
+#define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)       DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)         DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1(ret, func, args, argscall)              DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_3_0(ret, func, args, argscall)              DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall) DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall) DEFINEFUNC(ret, func, args, argscall)
+
+FOR_ALL_OPENSSL_FUNCTIONS
+
+#undef DEFINEFUNC
+#undef DEFINEFUNC_LEGACY_1_0
+#undef DEFINEFUNC_LEGACY_1
+#undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_3_0
+#undef DEFINEFUNC_RENAMED_1_1
+#undef DEFINEFUNC_RENAMED_3_0
+
+// Load all the functions stored in FOR_ALL_OPENSSL_FUNCTIONS
+// and assign them to their corresponding function pointer
+// defined in goopenssl.h.
+void
+go_openssl_load_functions(void* handle, int major, int minor)
+{
+#define DEFINEFUNC_INTERNAL(name, func) \
+    _g_##name = dlsym(handle, func);         \
+    if (_g_##name == NULL) { fprintf(stderr, "Cannot get required symbol " #func " from libcrypto version %d.%d\n", major, minor); abort(); }
+#define DEFINEFUNC(ret, func, args, argscall) \
+    DEFINEFUNC_INTERNAL(func, #func)
+#define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)  \
+    if (major == 1 && minor == 0)                         \
+    {                                                     \
+        DEFINEFUNC_INTERNAL(func, #func)                  \
+    }
+#define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)  \
+    if (major == 1)                                     \
+    {                                                   \
+        DEFINEFUNC_INTERNAL(func, #func)                \
+    }
+#define DEFINEFUNC_1_1(ret, func, args, argscall)     \
+    if (major == 3 || (major == 1 && minor == 1))     \
+    {                                                 \
+        DEFINEFUNC_INTERNAL(func, #func)              \
+    }
+#define DEFINEFUNC_3_0(ret, func, args, argscall)     \
+    if (major == 3)                                   \
+    {                                                 \
+        DEFINEFUNC_INTERNAL(func, #func)              \
+    }
+#define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall)  \
+    if (major == 1 && minor == 0)                                   \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #oldfunc)                         \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #func)                            \
+    }
+#define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall)  \
+    if (major == 1)                                                 \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #oldfunc)                         \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #func)                            \
+    }
+
+FOR_ALL_OPENSSL_FUNCTIONS
+
+#undef DEFINEFUNC
+#undef DEFINEFUNC_LEGACY_1_0
+#undef DEFINEFUNC_LEGACY_1
+#undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_3_0
+#undef DEFINEFUNC_RENAMED_1_1
+#undef DEFINEFUNC_RENAMED_3_0
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h
new file mode 100644
index 00000000000000..03aed43e001d54
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h
@@ -0,0 +1,147 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+// This header file describes the OpenSSL ABI as built for use in Go.
+
+#include <stdlib.h> // size_t
+
+#include "openssl_funcs.h"
+
+int go_openssl_version_major(void* handle);
+int go_openssl_version_minor(void* handle);
+int go_openssl_thread_setup(void);
+void go_openssl_load_functions(void* handle, int major, int minor);
+
+// Define pointers to all the used OpenSSL functions.
+// Calling C function pointers from Go is currently not supported.
+// It is possible to circumvent this by using a C function wrapper.
+// https://pkg.go.dev/cmd/cgo
+#define DEFINEFUNC(ret, func, args, argscall)      \
+    extern ret (*_g_##func)args;                   \
+    static inline ret go_openssl_##func args  \
+    {                                              \
+        return _g_##func argscall;                 \
+    }
+#define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)  \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)  \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1(ret, func, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_3_0(ret, func, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+
+FOR_ALL_OPENSSL_FUNCTIONS
+
+#undef DEFINEFUNC
+#undef DEFINEFUNC_LEGACY_1_0
+#undef DEFINEFUNC_LEGACY_1
+#undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_3_0
+#undef DEFINEFUNC_RENAMED_1_1
+#undef DEFINEFUNC_RENAMED_3_0
+
+// go_shaX is a SHA generic wrapper which hash p into out.
+// One shot sha functions are expected to be fast, so
+// we maximize performance by batching all cgo calls.
+static inline int
+go_shaX(GO_EVP_MD_PTR md, void *p, size_t n, void *out)
+{
+    GO_EVP_MD_CTX_PTR ctx = go_openssl_EVP_MD_CTX_new();
+    go_openssl_EVP_DigestInit_ex(ctx, md, NULL);
+    int ret = go_openssl_EVP_DigestUpdate(ctx, p, n) &&
+        go_openssl_EVP_DigestFinal_ex(ctx, out, NULL);
+    go_openssl_EVP_MD_CTX_free(ctx);
+    return ret;
+}
+
+// These wrappers allocate out_len on the C stack to avoid having to pass a pointer from Go, which would escape to the heap.
+// Use them only in situations where the output length can be safely discarded.
+static inline int
+go_openssl_EVP_EncryptUpdate_wrapper(GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, const unsigned char *in, int in_len)
+{
+    int len;
+    return go_openssl_EVP_EncryptUpdate(ctx, out, &len, in, in_len);
+}
+
+static inline int
+go_openssl_EVP_DecryptUpdate_wrapper(GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, const unsigned char *in, int in_len)
+{
+    int len;
+    return go_openssl_EVP_DecryptUpdate(ctx, out, &len, in, in_len);
+}
+
+static inline int
+go_openssl_EVP_CipherUpdate_wrapper(GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, const unsigned char *in, int in_len)
+{
+    int len;
+    return go_openssl_EVP_CipherUpdate(ctx, out, &len, in, in_len);
+}
+
+
+// These wrappers allocate out_len on the C stack, and check that it matches the expected
+// value, to avoid having to pass a pointer from Go, which would escape to the heap.
+
+static inline int
+go_openssl_EVP_CIPHER_CTX_seal_wrapper(const GO_EVP_CIPHER_CTX_PTR ctx,
+                                       unsigned char *out,
+                                       const unsigned char *nonce,
+                                       const unsigned char *in, int in_len,
+                                       const unsigned char *aad, int aad_len)
+{
+    if (in_len == 0) in = "";
+    if (aad_len == 0) aad = "";
+
+    if (go_openssl_EVP_CipherInit_ex(ctx, NULL, NULL, NULL, nonce, GO_AES_ENCRYPT) != 1)
+        return 0;
+
+    int discard_len, out_len;
+    if (go_openssl_EVP_EncryptUpdate(ctx, NULL, &discard_len, aad, aad_len) != 1
+        || go_openssl_EVP_EncryptUpdate(ctx, out, &out_len, in, in_len) != 1
+        || go_openssl_EVP_EncryptFinal_ex(ctx, out + out_len, &discard_len) != 1)
+    {
+        return 0;
+    }
+
+    if (in_len != out_len)
+        return 0;
+
+    return go_openssl_EVP_CIPHER_CTX_ctrl(ctx, GO_EVP_CTRL_GCM_GET_TAG, 16, out + out_len);
+};
+
+static inline int
+go_openssl_EVP_CIPHER_CTX_open_wrapper(const GO_EVP_CIPHER_CTX_PTR ctx,
+                                       unsigned char *out,
+                                       const unsigned char *nonce,
+                                       const unsigned char *in, int in_len,
+                                       const unsigned char *aad, int aad_len,
+                                       const unsigned char *tag)
+{
+    if (in_len == 0) in = "";
+    if (aad_len == 0) aad = "";
+
+    if (go_openssl_EVP_CipherInit_ex(ctx, NULL, NULL, NULL, nonce, GO_AES_DECRYPT) != 1)
+        return 0;
+
+    int discard_len, out_len;
+    if (go_openssl_EVP_DecryptUpdate(ctx, NULL, &discard_len, aad, aad_len) != 1
+        || go_openssl_EVP_DecryptUpdate(ctx, out, &out_len, in, in_len) != 1)
+    {
+        return 0;
+    }
+
+    if (go_openssl_EVP_CIPHER_CTX_ctrl(ctx, GO_EVP_CTRL_GCM_SET_TAG, 16, (unsigned char *)(tag)) != 1)
+        return 0;
+
+    if (go_openssl_EVP_DecryptFinal_ex(ctx, out + out_len, &discard_len) != 1)
+        return 0;
+
+    if (out_len != in_len)
+        return 0;
+
+    return 1;
+};
\ No newline at end of file
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go
new file mode 100644
index 00000000000000..81918cde673cee
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go
@@ -0,0 +1,251 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"hash"
+	"runtime"
+	"unsafe"
+)
+
+var (
+	paramAlgHMAC = C.CString("HMAC")
+	paramDigest  = C.CString("digest")
+)
+
+// NewHMAC returns a new HMAC using OpenSSL.
+// The function h must return a hash implemented by
+// OpenSSL (for example, h could be openssl.NewSHA256).
+// If h is not recognized, NewHMAC returns nil.
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
+	ch := h()
+	md := hashToMD(ch)
+	if md == nil {
+		return nil
+	}
+
+	var hkey []byte
+	if len(key) > 0 {
+		// Note: Could hash down long keys here using EVP_Digest.
+		hkey = make([]byte, len(key))
+		copy(hkey, key)
+	} else {
+		// This is supported in OpenSSL/Standard lib and as such
+		// we must support it here. When using HMAC with a null key
+		// HMAC_Init will try and reuse the key from the ctx. This is
+		// not the bahavior previously implemented, so as a workaround
+		// we pass an "empty" key.
+		hkey = make([]byte, C.GO_EVP_MAX_MD_SIZE)
+	}
+	switch vMajor {
+	case 1:
+		return newHMAC1(hkey, ch, md)
+	case 3:
+		return newHMAC3(hkey, ch, md)
+	default:
+		panic(errUnsuportedVersion())
+	}
+}
+
+// hmac1 implements hash.Hash
+// using functions available in OpenSSL 1.
+type hmac1 struct {
+	md        C.GO_EVP_MD_PTR
+	ctx       C.GO_HMAC_CTX_PTR
+	size      int
+	blockSize int
+	key       []byte
+	sum       []byte
+}
+
+func newHMAC1(key []byte, h hash.Hash, md C.GO_EVP_MD_PTR) *hmac1 {
+	hmac := &hmac1{
+		md:        md,
+		size:      h.Size(),
+		blockSize: h.BlockSize(),
+		key:       key,
+		ctx:       hmac1CtxNew(),
+	}
+	runtime.SetFinalizer(hmac, (*hmac1).finalize)
+	hmac.Reset()
+	return hmac
+}
+
+func (h *hmac1) Reset() {
+	hmac1CtxReset(h.ctx)
+
+	if C.go_openssl_HMAC_Init_ex(h.ctx, unsafe.Pointer(&h.key[0]), C.int(len(h.key)), h.md, nil) == 0 {
+		panic("openssl: HMAC_Init failed")
+	}
+	if size := C.go_openssl_EVP_MD_get_size(h.md); size != C.int(h.size) {
+		println("openssl: HMAC size:", size, "!=", h.size)
+		panic("openssl: HMAC size mismatch")
+	}
+	runtime.KeepAlive(h) // Next line will keep h alive too; just making doubly sure.
+	h.sum = nil
+}
+
+func (h *hmac1) finalize() {
+	hmac1CtxFree(h.ctx)
+}
+
+func (h *hmac1) Write(p []byte) (int, error) {
+	if len(p) > 0 {
+		C.go_openssl_HMAC_Update(h.ctx, base(p), C.size_t(len(p)))
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *hmac1) Size() int {
+	return h.size
+}
+
+func (h *hmac1) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *hmac1) Sum(in []byte) []byte {
+	if h.sum == nil {
+		size := h.Size()
+		h.sum = make([]byte, size)
+	}
+	// Make copy of context because Go hash.Hash mandates
+	// that Sum has no effect on the underlying stream.
+	// In particular it is OK to Sum, then Write more, then Sum again,
+	// and the second Sum acts as if the first didn't happen.
+	ctx2 := hmac1CtxNew()
+	defer hmac1CtxFree(ctx2)
+	if C.go_openssl_HMAC_CTX_copy(ctx2, h.ctx) == 0 {
+		panic("openssl: HMAC_CTX_copy failed")
+	}
+	C.go_openssl_HMAC_Final(ctx2, base(h.sum), nil)
+	return append(in, h.sum...)
+}
+
+func hmac1CtxNew() C.GO_HMAC_CTX_PTR {
+	if vMajor == 1 && vMinor == 0 {
+		// 0x120 is the sizeof value when building against OpenSSL 1.0.2 on Ubuntu 16.04.
+		ctx := (C.GO_HMAC_CTX_PTR)(C.malloc(0x120))
+		if ctx != nil {
+			C.go_openssl_HMAC_CTX_init(ctx)
+		}
+		return ctx
+	}
+	return C.go_openssl_HMAC_CTX_new()
+}
+
+func hmac1CtxReset(ctx C.GO_HMAC_CTX_PTR) {
+	if ctx == nil {
+		return
+	}
+	if vMajor == 1 && vMinor == 0 {
+		C.go_openssl_HMAC_CTX_cleanup(ctx)
+		C.go_openssl_HMAC_CTX_init(ctx)
+		return
+	}
+	C.go_openssl_HMAC_CTX_reset(ctx)
+}
+
+func hmac1CtxFree(ctx C.GO_HMAC_CTX_PTR) {
+	if ctx == nil {
+		return
+	}
+	if vMajor == 1 && vMinor == 0 {
+		C.go_openssl_HMAC_CTX_cleanup(ctx)
+		C.free(unsafe.Pointer(ctx))
+		return
+	}
+	C.go_openssl_HMAC_CTX_free(ctx)
+}
+
+// hmac3 implements hash.Hash
+// using functions available in OpenSSL 3.
+type hmac3 struct {
+	md        C.GO_EVP_MAC_PTR
+	ctx       C.GO_EVP_MAC_CTX_PTR
+	params    [2]C.OSSL_PARAM
+	size      int
+	blockSize int
+	key       []byte
+	sum       []byte
+}
+
+func newHMAC3(key []byte, h hash.Hash, md C.GO_EVP_MD_PTR) *hmac3 {
+	mac := C.go_openssl_EVP_MAC_fetch(nil, paramAlgHMAC, nil)
+	ctx := C.go_openssl_EVP_MAC_CTX_new(mac)
+	if ctx == nil {
+		panic("openssl: EVP_MAC_CTX_new failed")
+	}
+	digest := C.go_openssl_EVP_MD_get0_name(md)
+	params := [2]C.OSSL_PARAM{
+		C.go_openssl_OSSL_PARAM_construct_utf8_string(paramDigest, digest, 0),
+		C.go_openssl_OSSL_PARAM_construct_end(),
+	}
+	hmac := &hmac3{
+		md:        mac,
+		ctx:       ctx,
+		params:    params,
+		size:      h.Size(),
+		blockSize: h.BlockSize(),
+		key:       key,
+	}
+	runtime.SetFinalizer(hmac, (*hmac3).finalize)
+	hmac.Reset()
+	return hmac
+}
+
+func (h *hmac3) Reset() {
+	if C.go_openssl_EVP_MAC_init(h.ctx, base(h.key), C.size_t(len(h.key)), &h.params[0]) == 0 {
+		panic(newOpenSSLError("EVP_MAC_init failed"))
+	}
+	runtime.KeepAlive(h) // Next line will keep h alive too; just making doubly sure.
+	h.sum = nil
+}
+
+func (h *hmac3) finalize() {
+	if h.ctx == nil {
+		return
+	}
+	C.go_openssl_EVP_MAC_CTX_free(h.ctx)
+}
+
+func (h *hmac3) Write(p []byte) (int, error) {
+	if len(p) > 0 {
+		C.go_openssl_EVP_MAC_update(h.ctx, base(p), C.size_t(len(p)))
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *hmac3) Size() int {
+	return h.size
+}
+
+func (h *hmac3) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *hmac3) Sum(in []byte) []byte {
+	if h.sum == nil {
+		size := h.Size()
+		h.sum = make([]byte, size)
+	}
+	// Make copy of context because Go hash.Hash mandates
+	// that Sum has no effect on the underlying stream.
+	// In particular it is OK to Sum, then Write more, then Sum again,
+	// and the second Sum acts as if the first didn't happen.
+	ctx2 := C.go_openssl_EVP_MAC_CTX_dup(h.ctx)
+	if ctx2 == nil {
+		panic("openssl: EVP_MAC_CTX_dup failed")
+	}
+	defer C.go_openssl_EVP_MAC_CTX_free(ctx2)
+	C.go_openssl_EVP_MAC_final(ctx2, base(h.sum), nil, C.size_t(len(h.sum)))
+	return append(in, h.sum...)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/internal/subtle/aliasing.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/internal/subtle/aliasing.go
new file mode 100644
index 00000000000000..db09e4aae64f8c
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/internal/subtle/aliasing.go
@@ -0,0 +1,32 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package subtle implements functions that are often useful in cryptographic
+// code but require careful thought to use correctly.
+//
+// This is a mirror of golang.org/x/crypto/internal/subtle.
+package subtle
+
+import "unsafe"
+
+// AnyOverlap reports whether x and y share memory at any (not necessarily
+// corresponding) index. The memory beyond the slice length is ignored.
+func AnyOverlap(x, y []byte) bool {
+	return len(x) > 0 && len(y) > 0 &&
+		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
+		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
+}
+
+// InexactOverlap reports whether x and y share memory at any non-corresponding
+// index. The memory beyond the slice length is ignored. Note that x and y can
+// have different lengths and still not have any inexact overlap.
+//
+// InexactOverlap can be used to implement the requirements of the crypto/cipher
+// AEAD, Block, BlockMode and Stream interfaces.
+func InexactOverlap(x, y []byte) bool {
+	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
+		return false
+	}
+	return AnyOverlap(x, y)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go
new file mode 100644
index 00000000000000..e3e13d793c4d8b
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go
@@ -0,0 +1,302 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+// Package openssl provides access to OpenSSL cryptographic functions.
+package openssl
+
+// #include "goopenssl.h"
+// #include <dlfcn.h>
+// #cgo LDFLAGS: -ldl
+import "C"
+import (
+	"errors"
+	"math/bits"
+	"strconv"
+	"strings"
+	"sync"
+	"syscall"
+	"unsafe"
+)
+
+var (
+	providerNameFips    = C.CString("fips")
+	providerNameDefault = C.CString("default")
+	propFipsYes         = C.CString("fips=yes")
+	propFipsNo          = C.CString("fips=no")
+	algProve            = C.CString("SHA2-256")
+)
+
+var (
+	initOnce sync.Once
+	// errInit is set when first calling Init().
+	errInit error
+	// vMajor and vMinor hold the major/minor OpenSSL version.
+	// It is only populated if Init has been called.
+	vMajor, vMinor int
+)
+
+// knownVersions is a list of supported and well-known libcrypto.so suffixes in decreasing version order.
+//
+// FreeBSD library version numbering does not directly align to the version of OpenSSL.
+// Its preferred search order is 11 -> 111.
+//
+// Some distributions use 1.0.0 and others (such as Debian) 1.0.2 to refer to the same OpenSSL 1.0.2 version.
+//
+// Fedora derived distros use different naming for the version 1.0.x.
+var knownVersions = [...]string{"3", "1.1", "11", "111", "1.0.2", "1.0.0", "10"}
+
+func errUnsuportedVersion() error {
+	return errors.New("openssl: OpenSSL version: " + strconv.Itoa(vMajor) + "." + strconv.Itoa(vMinor))
+}
+
+// Init loads and initializes OpenSSL.
+// It must be called before any other OpenSSL call.
+//
+// Only the first call to Init is effective,
+// subsequent calls will return the same error result as the one from the first call.
+//
+// If GO_OPENSSL_VERSION_OVERRIDE environment variable is not empty, its value will be appended to the OpenSSL shared library name
+// as a version suffix when calling dlopen. For example, "GO_OPENSSL_VERSION_OVERRIDE=1.1.1k-fips"
+// makes Init look for the shared library libcrypto.so.1.1.1k-fips.
+// If GO_OPENSSL_VERSION_OVERRIDE environment variable is empty, Init will try to load the OpenSSL shared library
+// using a list if supported and well-known version suffixes, going from higher to lower versions.
+func Init() error {
+	initOnce.Do(func() {
+		version, _ := syscall.Getenv("GO_OPENSSL_VERSION_OVERRIDE")
+		handle, err := loadLibrary(version)
+		if err != nil {
+			errInit = err
+			return
+		}
+
+		vMajor = int(C.go_openssl_version_major(handle))
+		vMinor = int(C.go_openssl_version_minor(handle))
+		if vMajor == -1 || vMinor == -1 {
+			errInit = errors.New("openssl: can't retrieve OpenSSL version")
+			return
+		}
+		var supported bool
+		if vMajor == 1 {
+			supported = vMinor == 0 || vMinor == 1
+		} else if vMajor == 3 {
+			// OpenSSL team guarantees API and ABI compatibility within the same major version since OpenSSL 3.
+			supported = true
+		}
+		if !supported {
+			errInit = errUnsuportedVersion()
+			return
+		}
+
+		C.go_openssl_load_functions(handle, C.int(vMajor), C.int(vMinor))
+		C.go_openssl_OPENSSL_init()
+		if vMajor == 1 && vMinor == 0 {
+			if C.go_openssl_thread_setup() != 1 {
+				errInit = newOpenSSLError("openssl: thread setup")
+				return
+			}
+			C.go_openssl_OPENSSL_add_all_algorithms_conf()
+			C.go_openssl_ERR_load_crypto_strings()
+		} else {
+			flags := C.uint64_t(C.GO_OPENSSL_INIT_ADD_ALL_CIPHERS | C.GO_OPENSSL_INIT_ADD_ALL_DIGESTS | C.GO_OPENSSL_INIT_LOAD_CONFIG | C.GO_OPENSSL_INIT_LOAD_CRYPTO_STRINGS)
+			if C.go_openssl_OPENSSL_init_crypto(flags, nil) != 1 {
+				errInit = newOpenSSLError("openssl: init crypto")
+				return
+			}
+		}
+	})
+	return errInit
+}
+
+func dlopen(version string) unsafe.Pointer {
+	cv := C.CString("libcrypto.so." + version)
+	defer C.free(unsafe.Pointer(cv))
+	return C.dlopen(cv, C.RTLD_LAZY|C.RTLD_LOCAL)
+}
+
+func loadLibrary(version string) (unsafe.Pointer, error) {
+	if version != "" {
+		// If version is specified try to load it or error out.
+		handle := dlopen(version)
+		if handle == nil {
+			errstr := C.GoString(C.dlerror())
+			return nil, errors.New("openssl: can't load libcrypto.so." + version + ": " + errstr)
+		}
+		return handle, nil
+	}
+	for _, v := range knownVersions {
+		handle := dlopen(v)
+		if handle != nil {
+			return handle, nil
+		}
+	}
+	return nil, errors.New("openssl: can't load libcrypto.so using any known version suffix")
+}
+
+// providerAvailable looks through provider's digests
+// checking if there is any that matches the props query.
+func providerAvailable(props *C.char) bool {
+	C.go_openssl_ERR_set_mark()
+	md := C.go_openssl_EVP_MD_fetch(nil, algProve, props)
+	C.go_openssl_ERR_pop_to_mark()
+	if md == nil {
+		return false
+	}
+	C.go_openssl_EVP_MD_free(md)
+	return true
+}
+
+// FIPS returns true if OpenSSL is running in FIPS mode, else returns false.
+func FIPS() bool {
+	switch vMajor {
+	case 1:
+		return C.go_openssl_FIPS_mode() == 1
+	case 3:
+		if C.go_openssl_EVP_default_properties_is_fips_enabled(nil) == 0 {
+			return false
+		}
+		// EVP_default_properties_is_fips_enabled can return true even if the FIPS provider isn't loaded,
+		// it is only based on the default properties.
+		return providerAvailable(propFipsYes)
+	default:
+		panic(errUnsuportedVersion())
+	}
+}
+
+// SetFIPS enables or disables FIPS mode.
+//
+// It implements the following provider fallback logic for OpenSSL 3:
+//    - The "fips" provider is loaded if enabled=true and no loaded provider matches "fips=yes".
+//    - The "default" provider is loaded if enabled=false and no loaded provider matches "fips=no".
+// This logic allows advanced users to define their own providers that match "fips=yes" and "fips=no" using the OpenSSL config file.
+func SetFIPS(enabled bool) error {
+	switch vMajor {
+	case 1:
+		var mode C.int
+		if enabled {
+			mode = C.int(1)
+		} else {
+			mode = C.int(0)
+		}
+		if C.go_openssl_FIPS_mode_set(mode) != 1 {
+			return newOpenSSLError("openssl: FIPS_mode_set")
+		}
+		return nil
+	case 3:
+		var props, provName *C.char
+		if enabled {
+			props = propFipsYes
+			provName = providerNameFips
+		} else {
+			props = propFipsNo
+			provName = providerNameDefault
+		}
+		// Check if there is any provider that matches props.
+		if !providerAvailable(props) {
+			// If not, fallback to provName provider.
+			if C.go_openssl_OSSL_PROVIDER_load(nil, provName) == nil {
+				return newOpenSSLError("openssl: OSSL_PROVIDER_try_load")
+			}
+			// Make sure we now have a provider available.
+			if !providerAvailable(props) {
+				return fail("SetFIPS(" + strconv.FormatBool(enabled) + ") not supported")
+			}
+		}
+		if C.go_openssl_EVP_set_default_properties(nil, props) != 1 {
+			return newOpenSSLError("openssl: EVP_set_default_properties")
+		}
+		return nil
+	default:
+		panic(errUnsuportedVersion())
+	}
+}
+
+// VersionText returns the version text of the OpenSSL currently loaded.
+func VersionText() string {
+	return C.GoString(C.go_openssl_OpenSSL_version(0))
+}
+
+func newOpenSSLError(msg string) error {
+	var b strings.Builder
+	var e C.ulong
+
+	b.WriteString(msg)
+	b.WriteString("\nopenssl error(s):\n")
+
+	for {
+		e = C.go_openssl_ERR_get_error()
+		if e == 0 {
+			break
+		}
+		var buf [256]byte
+		C.go_openssl_ERR_error_string_n(e, (*C.char)(unsafe.Pointer(&buf[0])), 256)
+		b.Write(buf[:])
+		b.WriteByte('\n')
+	}
+	return errors.New(b.String())
+}
+
+type fail string
+
+func (e fail) Error() string { return "openssl: " + string(e) + " failed" }
+
+const wordBytes = bits.UintSize / 8
+
+func wbase(b BigInt) *C.uchar {
+	if len(b) == 0 {
+		return nil
+	}
+	return (*C.uchar)(unsafe.Pointer(&b[0]))
+}
+
+func bytesToBN(x []byte) C.GO_BIGNUM_PTR {
+	if len(x) == 0 {
+		return nil
+	}
+	return C.go_openssl_BN_bin2bn(base(x), C.int(len(x)), nil)
+}
+
+func bigToBN(x BigInt) C.GO_BIGNUM_PTR {
+	if len(x) == 0 {
+		return nil
+	}
+	return C.go_openssl_BN_lebin2bn(wbase(x), C.int(len(x)*wordBytes), nil)
+}
+
+func bnToBig(bn C.GO_BIGNUM_PTR) BigInt {
+	if bn == nil {
+		return nil
+	}
+	x := make(BigInt, C.go_openssl_BN_num_bits(bn))
+	if C.go_openssl_BN_bn2lebinpad(bn, wbase(x), C.int(len(x)*wordBytes)) == 0 {
+		panic("openssl: bignum conversion failed")
+	}
+	return x
+}
+
+// noescape hides a pointer from escape analysis. noescape is
+// the identity function but escape analysis doesn't think the
+// output depends on the input. noescape is inlined and currently
+// compiles down to zero instructions.
+// USE CAREFULLY!
+//go:nosplit
+func noescape(p unsafe.Pointer) unsafe.Pointer {
+	x := uintptr(p)
+	return unsafe.Pointer(x ^ 0)
+}
+
+var zero byte
+
+// addr converts p to its base addr, including a noescape along the way.
+// If p is nil, addr returns a non-nil pointer, so that the result can always
+// be dereferenced.
+//
+//go:nosplit
+func addr(p []byte) *byte {
+	if len(p) == 0 {
+		return &zero
+	}
+	return (*byte)(noescape(unsafe.Pointer(&p[0])))
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h
new file mode 100644
index 00000000000000..fe72f90e9c7bba
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h
@@ -0,0 +1,293 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+// To make this header standalone (so that building Go does not require
+// having a full set of OpenSSL headers), the struct details are not here.
+// Instead, while testing the openssl module, we generate and compile a C program
+// that checks that the function signatures match the OpenSSL equivalents.
+// The generation of the checking program depends on the declaration
+// forms used below, which includes commented directives (#include, #if and #endif)
+// and comments starting with `check:`.
+
+#include <stdlib.h> // size_t
+#include <stdint.h> // uint64_t
+
+// #include <openssl/crypto.h>
+enum {
+    GO_OPENSSL_INIT_LOAD_CRYPTO_STRINGS = 0x00000002L,
+    GO_OPENSSL_INIT_ADD_ALL_CIPHERS = 0x00000004L,
+    GO_OPENSSL_INIT_ADD_ALL_DIGESTS = 0x00000008L,
+    GO_OPENSSL_INIT_LOAD_CONFIG = 0x00000040L
+};
+
+// #include <openssl/aes.h>
+enum {
+    GO_AES_ENCRYPT = 1,
+    GO_AES_DECRYPT = 0
+};
+
+// #include <openssl/evp.h>
+enum {
+    GO_EVP_CTRL_GCM_GET_TAG = 0x10,
+    GO_EVP_CTRL_GCM_SET_TAG = 0x11,
+    GO_EVP_PKEY_CTRL_MD = 1,
+    GO_EVP_PKEY_RSA = 6,
+    GO_EVP_PKEY_EC = 408,
+    GO_EVP_MAX_MD_SIZE = 64
+};
+
+// #include <openssl/ec.h>
+enum {
+    GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID = 0x1001,
+};
+
+typedef enum {
+    GO_POINT_CONVERSION_UNCOMPRESSED = 4,
+} point_conversion_form_t;
+
+// #include <openssl/obj_mac.h>
+enum {
+    GO_NID_X9_62_prime256v1 = 415,
+    GO_NID_secp224r1 = 713,
+    GO_NID_secp384r1 = 715,
+    GO_NID_secp521r1 = 716
+};
+
+// #include <openssl/rsa.h>
+enum {
+    GO_RSA_PKCS1_PADDING = 1,
+    GO_RSA_NO_PADDING = 3,
+    GO_RSA_PKCS1_OAEP_PADDING = 4,
+    GO_RSA_PKCS1_PSS_PADDING = 6,
+    GO_RSA_PSS_SALTLEN_DIGEST = -1,
+    GO_RSA_PSS_SALTLEN_AUTO = -2,
+    GO_RSA_PSS_SALTLEN_MAX_SIGN = -2,
+    GO_RSA_PSS_SALTLEN_MAX = -3,
+    GO_EVP_PKEY_CTRL_RSA_PADDING = 0x1001,
+    GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN = 0x1002,
+    GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS = 0x1003,
+    GO_EVP_PKEY_CTRL_RSA_MGF1_MD = 0x1005,
+    GO_EVP_PKEY_CTRL_RSA_OAEP_MD = 0x1009,
+    GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL = 0x100A
+};
+
+typedef void* GO_EVP_CIPHER_PTR;
+typedef void* GO_EVP_CIPHER_CTX_PTR;
+typedef void* GO_EVP_PKEY_PTR;
+typedef void* GO_EVP_PKEY_CTX_PTR;
+typedef void* GO_EVP_MD_PTR;
+typedef void* GO_EVP_MD_CTX_PTR;
+typedef void* GO_HMAC_CTX_PTR;
+typedef void* GO_OPENSSL_INIT_SETTINGS_PTR;
+typedef void* GO_OSSL_LIB_CTX_PTR;
+typedef void* GO_OSSL_PROVIDER_PTR;
+typedef void* GO_ENGINE_PTR;
+typedef void* GO_BIGNUM_PTR;
+typedef void* GO_BN_CTX_PTR;
+typedef void* GO_EC_KEY_PTR;
+typedef void* GO_EC_POINT_PTR;
+typedef void* GO_EC_GROUP_PTR;
+typedef void* GO_RSA_PTR;
+typedef void* GO_EVP_MAC_PTR;
+typedef void* GO_EVP_MAC_CTX_PTR;
+
+// OSSL_PARAM does not follow the GO_FOO_PTR pattern
+// because it is not passed around as a pointer but on the stack.
+// We can't abstract it away by using a void*.
+// Copied from
+// https://github.com/openssl/openssl/blob/fcae2ae4f675def607d338b7945b9af1dd9bb746/include/openssl/core.h#L82-L88.
+typedef struct {
+    const char *key;
+    unsigned int data_type;
+    void *data;
+    size_t data_size;
+    size_t return_size;
+} OSSL_PARAM;
+
+// List of all functions from the libcrypto that are used in this package.
+// Forgetting to add a function here results in build failure with message reporting the function
+// that needs to be added.
+//
+// The purpose of FOR_ALL_OPENSSL_FUNCTIONS is to define all libcrypto functions
+// without depending on the openssl headers so it is easier to use this package
+// with an openssl version different that the one used at build time.
+//
+// The following macros may not be defined at this point,
+// they are not resolved here but just accumulated in FOR_ALL_OPENSSL_FUNCTIONS.
+//
+// DEFINEFUNC defines and loads openssl functions that can be directly called from Go as their signatures match
+// the OpenSSL API and do not require special logic.
+// The process will be aborted if the function can't be loaded.
+//
+// DEFINEFUNC_LEGACY_1_0 acts like DEFINEFUNC but only aborts the process if the function can't be loaded
+// when using 1.0.x. This indicates the function is required when using 1.0.x, but is unused when using later versions.
+// It also might not exist in later versions.
+//
+// DEFINEFUNC_LEGACY_1 acts like DEFINEFUNC but only aborts the process if the function can't be loaded
+// when using 1.x. This indicates the function is required when using 1.x, but is unused when using later versions.
+// It also might not exist in later versions.
+//
+// DEFINEFUNC_1_1 acts like DEFINEFUNC but only aborts the process if function can't be loaded
+// when using 1.1.0 or higher.
+//
+// DEFINEFUNC_3_0 acts like DEFINEFUNC but only aborts the process if function can't be loaded
+// when using 3.0.0 or higher.
+//
+// DEFINEFUNC_RENAMED_1_1 acts like DEFINEFUNC but tries to load the function using the new name when using >= 1.1.x
+// and the old name when using 1.0.2. In both cases the function will have the new name.
+//
+// DEFINEFUNC_RENAMED_3_0 acts like DEFINEFUNC but tries to load the function using the new name when using >= 3.x
+// and the old name when using 1.x. In both cases the function will have the new name.
+//
+// #include <openssl/crypto.h>
+// #include <openssl/err.h>
+// #include <openssl/rsa.h>
+// #include <openssl/hmac.h>
+// #include <openssl/ec.h>
+// #include <openssl/rand.h>
+// #include <openssl/evp.h>
+// #if OPENSSL_VERSION_NUMBER >= 0x30000000L
+// #include <openssl/provider.h>
+// #endif
+#define FOR_ALL_OPENSSL_FUNCTIONS \
+DEFINEFUNC(int, ERR_set_mark, (void), ()) \
+DEFINEFUNC(int, ERR_pop_to_mark, (void), ()) \
+DEFINEFUNC(unsigned long, ERR_get_error, (void), ()) \
+DEFINEFUNC(void, ERR_error_string_n, (unsigned long e, char *buf, size_t len), (e, buf, len)) \
+DEFINEFUNC_RENAMED_1_1(const char *, OpenSSL_version, SSLeay_version, (int type), (type)) \
+DEFINEFUNC(void, OPENSSL_init, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(void, ERR_load_crypto_strings, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(int, CRYPTO_num_locks, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(void, CRYPTO_set_id_callback, (unsigned long (*id_function)(void)), (id_function)) \
+DEFINEFUNC_LEGACY_1_0(void, CRYPTO_set_locking_callback, (void (*locking_function)(int mode, int n, const char *file, int line)), (locking_function)) \
+DEFINEFUNC_LEGACY_1_0(void, OPENSSL_add_all_algorithms_conf, (void), ()) \
+DEFINEFUNC_1_1(int, OPENSSL_init_crypto, (uint64_t ops, const GO_OPENSSL_INIT_SETTINGS_PTR settings), (ops, settings)) \
+DEFINEFUNC_LEGACY_1(int, FIPS_mode, (void), ()) \
+DEFINEFUNC_LEGACY_1(int, FIPS_mode_set, (int r), (r)) \
+DEFINEFUNC_3_0(int, EVP_default_properties_is_fips_enabled, (GO_OSSL_LIB_CTX_PTR libctx), (libctx)) \
+DEFINEFUNC_3_0(int, EVP_set_default_properties, (GO_OSSL_LIB_CTX_PTR libctx, const char *propq), (libctx, propq)) \
+DEFINEFUNC_3_0(GO_OSSL_PROVIDER_PTR, OSSL_PROVIDER_load, (GO_OSSL_LIB_CTX_PTR libctx, const char *name), (libctx, name)) \
+DEFINEFUNC(int, RAND_bytes, (unsigned char* arg0, int arg1), (arg0, arg1)) \
+DEFINEFUNC(int, EVP_DigestInit, (GO_EVP_MD_CTX_PTR ctx, const GO_EVP_MD_PTR type), (ctx, type)) \
+DEFINEFUNC(int, EVP_DigestInit_ex, (GO_EVP_MD_CTX_PTR ctx, const GO_EVP_MD_PTR type, GO_ENGINE_PTR impl), (ctx, type, impl)) \
+DEFINEFUNC(int, EVP_DigestUpdate, (GO_EVP_MD_CTX_PTR ctx, const void *d, size_t cnt), (ctx, d, cnt)) \
+DEFINEFUNC(int, EVP_DigestFinal_ex, (GO_EVP_MD_CTX_PTR ctx, unsigned char *md, unsigned int *s), (ctx, md, s)) \
+DEFINEFUNC(int, EVP_DigestFinal, (GO_EVP_MD_CTX_PTR ctx, unsigned char *md, unsigned int *s), (ctx, md, s)) \
+DEFINEFUNC_RENAMED_1_1(GO_EVP_MD_CTX_PTR, EVP_MD_CTX_new, EVP_MD_CTX_create, (), ()) \
+DEFINEFUNC_RENAMED_1_1(void, EVP_MD_CTX_free, EVP_MD_CTX_destroy, (GO_EVP_MD_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_MD_CTX_copy_ex, (GO_EVP_MD_CTX_PTR out, const GO_EVP_MD_CTX_PTR in), (out, in)) \
+DEFINEFUNC(int, EVP_MD_CTX_copy, (GO_EVP_MD_CTX_PTR out, const GO_EVP_MD_CTX_PTR in), (out, in)) \
+DEFINEFUNC_RENAMED_1_1(int, EVP_MD_CTX_reset, EVP_MD_CTX_cleanup, (GO_EVP_MD_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC_3_0(const char *, EVP_MD_get0_name, (const GO_EVP_MD_PTR md), (md)) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_md5, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha1, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha224, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha256, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha384, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha512, (void), ()) \
+DEFINEFUNC_1_1(const GO_EVP_MD_PTR, EVP_md5_sha1, (void), ()) \
+DEFINEFUNC_3_0(GO_EVP_MD_PTR, EVP_MD_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(void, EVP_MD_free, (GO_EVP_MD_PTR md), (md)) \
+DEFINEFUNC_RENAMED_3_0(int, EVP_MD_get_size, EVP_MD_size, (const GO_EVP_MD_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1_0(void, HMAC_CTX_init, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1_0(void, HMAC_CTX_cleanup, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, HMAC_Init_ex, (GO_HMAC_CTX_PTR arg0, const void *arg1, int arg2, const GO_EVP_MD_PTR arg3, GO_ENGINE_PTR arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, HMAC_Update, (GO_HMAC_CTX_PTR arg0, const unsigned char *arg1, size_t arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC(int, HMAC_Final, (GO_HMAC_CTX_PTR arg0, unsigned char *arg1, unsigned int *arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC(int, HMAC_CTX_copy, (GO_HMAC_CTX_PTR dest, GO_HMAC_CTX_PTR src), (dest, src)) \
+DEFINEFUNC_1_1(void, HMAC_CTX_free, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_1_1(GO_HMAC_CTX_PTR, HMAC_CTX_new, (void), ()) \
+DEFINEFUNC_1_1(int, HMAC_CTX_reset, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(GO_EVP_CIPHER_CTX_PTR, EVP_CIPHER_CTX_new, (void), ()) \
+DEFINEFUNC(int, EVP_CIPHER_CTX_set_padding, (GO_EVP_CIPHER_CTX_PTR x, int padding), (x, padding)) \
+DEFINEFUNC(int, EVP_CipherInit_ex, (GO_EVP_CIPHER_CTX_PTR ctx, const GO_EVP_CIPHER_PTR type, GO_ENGINE_PTR impl, const unsigned char *key, const unsigned char *iv, int enc), (ctx, type, impl, key, iv, enc)) \
+DEFINEFUNC(int, EVP_CipherUpdate, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl, const unsigned char *in, int inl), (ctx, out, outl, in, inl)) \
+DEFINEFUNC(GO_BIGNUM_PTR, BN_new, (void), ()) \
+DEFINEFUNC(void, BN_free, (GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(void, BN_clear_free, (GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(int, BN_num_bits, (const GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(GO_BIGNUM_PTR, BN_bin2bn, (const unsigned char *arg0, int arg1, GO_BIGNUM_PTR arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC(int, BN_bn2bin, (const GO_BIGNUM_PTR arg0, unsigned char *arg1), (arg0, arg1)) \
+/* bn_lebin2bn, bn_bn2lebinpad and BN_bn2binpad are not exported in any OpenSSL 1.0.2, but they exist. */ \
+/*check:from=1.1.0*/ DEFINEFUNC_RENAMED_1_1(GO_BIGNUM_PTR, BN_lebin2bn, bn_lebin2bn, (const unsigned char *s, int len, GO_BIGNUM_PTR ret), (s, len, ret)) \
+/*check:from=1.1.0*/ DEFINEFUNC_RENAMED_1_1(int, BN_bn2lebinpad, bn_bn2lebinpad, (const GO_BIGNUM_PTR a, unsigned char *to, int tolen), (a, to, tolen)) \
+/*check:from=1.1.0*/ DEFINEFUNC_RENAMED_1_1(int, BN_bn2binpad, bn_bn2binpad, (const GO_BIGNUM_PTR a, unsigned char *to, int tolen), (a, to, tolen)) \
+DEFINEFUNC(void, EC_GROUP_free, (GO_EC_GROUP_PTR arg0), (arg0)) \
+DEFINEFUNC(GO_EC_POINT_PTR, EC_POINT_new, (const GO_EC_GROUP_PTR arg0), (arg0)) \
+DEFINEFUNC(void, EC_POINT_free, (GO_EC_POINT_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EC_POINT_get_affine_coordinates_GFp, (const GO_EC_GROUP_PTR arg0, const GO_EC_POINT_PTR arg1, GO_BIGNUM_PTR arg2, GO_BIGNUM_PTR arg3, GO_BN_CTX_PTR arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(size_t, EC_POINT_point2oct, (const GO_EC_GROUP_PTR group, const GO_EC_POINT_PTR p, point_conversion_form_t form, unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (group, p, form, buf, len, ctx)) \
+DEFINEFUNC_LEGACY_1_0(int, EC_POINT_oct2point, (const GO_EC_GROUP_PTR group, GO_EC_POINT_PTR p, const unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (group, p, buf, len, ctx)) \
+DEFINEFUNC(int, EC_POINT_mul, (const GO_EC_GROUP_PTR group, GO_EC_POINT_PTR r, const GO_BIGNUM_PTR n, const GO_EC_POINT_PTR q, const GO_BIGNUM_PTR m, GO_BN_CTX_PTR ctx), (group, r, n, q, m, ctx)) \
+DEFINEFUNC(GO_EC_KEY_PTR, EC_KEY_new_by_curve_name, (int arg0), (arg0)) \
+DEFINEFUNC(int, EC_KEY_set_public_key_affine_coordinates, (GO_EC_KEY_PTR key, GO_BIGNUM_PTR x, GO_BIGNUM_PTR y), (key, x, y)) \
+DEFINEFUNC_LEGACY_1_0(int, EC_KEY_set_public_key, (GO_EC_KEY_PTR key, const GO_EC_POINT_PTR pub), (key, pub)) \
+DEFINEFUNC(void, EC_KEY_free, (GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC(const GO_EC_GROUP_PTR, EC_KEY_get0_group, (const GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EC_KEY_set_private_key, (GO_EC_KEY_PTR arg0, const GO_BIGNUM_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC_1_1(int, EC_KEY_oct2key, (GO_EC_KEY_PTR eckey, const unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (eckey, buf, len, ctx)) \
+DEFINEFUNC(const GO_BIGNUM_PTR, EC_KEY_get0_private_key, (const GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC(const GO_EC_POINT_PTR, EC_KEY_get0_public_key, (const GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC(GO_RSA_PTR, RSA_new, (void), ()) \
+DEFINEFUNC(void, RSA_free, (GO_RSA_PTR arg0), (arg0)) \
+DEFINEFUNC_1_1(int, RSA_set0_factors, (GO_RSA_PTR rsa, GO_BIGNUM_PTR p, GO_BIGNUM_PTR q), (rsa, p, q)) \
+DEFINEFUNC_1_1(int, RSA_set0_crt_params, (GO_RSA_PTR rsa, GO_BIGNUM_PTR dmp1, GO_BIGNUM_PTR dmp2,GO_BIGNUM_PTR iqmp), (rsa, dmp1, dmp2, iqmp)) \
+DEFINEFUNC_1_1(void, RSA_get0_crt_params, (const GO_RSA_PTR r, const GO_BIGNUM_PTR *dmp1, const GO_BIGNUM_PTR *dmq1, const GO_BIGNUM_PTR *iqmp), (r, dmp1, dmq1, iqmp)) \
+DEFINEFUNC_1_1(int, RSA_set0_key, (GO_RSA_PTR r, GO_BIGNUM_PTR n, GO_BIGNUM_PTR e, GO_BIGNUM_PTR d), (r, n, e, d)) \
+DEFINEFUNC_1_1(void, RSA_get0_factors, (const GO_RSA_PTR rsa, const GO_BIGNUM_PTR *p, const GO_BIGNUM_PTR *q), (rsa, p, q)) \
+DEFINEFUNC_1_1(void, RSA_get0_key, (const GO_RSA_PTR rsa, const GO_BIGNUM_PTR *n, const GO_BIGNUM_PTR *e, const GO_BIGNUM_PTR *d), (rsa, n, e, d)) \
+DEFINEFUNC(int, EVP_EncryptInit_ex, (GO_EVP_CIPHER_CTX_PTR ctx, const GO_EVP_CIPHER_PTR type, GO_ENGINE_PTR impl, const unsigned char *key, const unsigned char *iv), (ctx, type, impl, key, iv)) \
+DEFINEFUNC(int, EVP_EncryptUpdate, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl, const unsigned char *in, int inl), (ctx, out, outl, in, inl)) \
+DEFINEFUNC(int, EVP_EncryptFinal_ex, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl), (ctx, out, outl)) \
+DEFINEFUNC(int, EVP_DecryptUpdate, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl, const unsigned char *in, int inl),	(ctx, out, outl, in, inl)) \
+DEFINEFUNC(int, EVP_DecryptFinal_ex, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *outm, int *outl),	(ctx, outm, outl)) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_gcm, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_ctr, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_gcm, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_ctr, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_ctr, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_gcm, (void), ()) \
+DEFINEFUNC(void, EVP_CIPHER_CTX_free, (GO_EVP_CIPHER_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_CIPHER_CTX_ctrl, (GO_EVP_CIPHER_CTX_PTR ctx, int type, int arg, void *ptr), (ctx, type, arg, ptr)) \
+DEFINEFUNC(GO_EVP_PKEY_PTR, EVP_PKEY_new, (void), ()) \
+/* EVP_PKEY_size and EVP_PKEY_get_bits pkey parameter is const since OpenSSL 1.1.1. */ \
+/* Exclude it from headercheck tool when using previous OpenSSL versions. */ \
+/*check:from=1.1.1*/ DEFINEFUNC_RENAMED_3_0(int, EVP_PKEY_get_size, EVP_PKEY_size, (const GO_EVP_PKEY_PTR pkey), (pkey)) \
+/*check:from=1.1.1*/ DEFINEFUNC_RENAMED_3_0(int, EVP_PKEY_get_bits, EVP_PKEY_bits, (const GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC(void, EVP_PKEY_free, (GO_EVP_PKEY_PTR arg0), (arg0)) \
+DEFINEFUNC(GO_EC_KEY_PTR, EVP_PKEY_get1_EC_KEY, (GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC(GO_RSA_PTR, EVP_PKEY_get1_RSA, (GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC(int, EVP_PKEY_assign, (GO_EVP_PKEY_PTR pkey, int type, void *key), (pkey, type, key)) \
+DEFINEFUNC(int, EVP_PKEY_verify, (GO_EVP_PKEY_CTX_PTR ctx, const unsigned char *sig, size_t siglen, const unsigned char *tbs, size_t tbslen), (ctx, sig, siglen, tbs, tbslen)) \
+DEFINEFUNC(GO_EVP_PKEY_CTX_PTR, EVP_PKEY_CTX_new, (GO_EVP_PKEY_PTR arg0, GO_ENGINE_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC(GO_EVP_PKEY_CTX_PTR, EVP_PKEY_CTX_new_id, (int id, GO_ENGINE_PTR e), (id, e)) \
+DEFINEFUNC(int, EVP_PKEY_keygen_init, (GO_EVP_PKEY_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_PKEY_keygen, (GO_EVP_PKEY_CTX_PTR ctx, GO_EVP_PKEY_PTR *ppkey), (ctx, ppkey)) \
+DEFINEFUNC(void, EVP_PKEY_CTX_free, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_CTX_ctrl, (GO_EVP_PKEY_CTX_PTR ctx, int keytype, int optype, int cmd, int p1, void *p2), (ctx, keytype, optype, cmd, p1, p2)) \
+DEFINEFUNC(int, EVP_PKEY_decrypt, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_encrypt, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_decrypt_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_encrypt_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_sign_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_verify_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_sign, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_derive_init, (GO_EVP_PKEY_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_PKEY_derive_set_peer, (GO_EVP_PKEY_CTX_PTR ctx, GO_EVP_PKEY_PTR peer), (ctx, peer)) \
+DEFINEFUNC(int, EVP_PKEY_derive, (GO_EVP_PKEY_CTX_PTR ctx, unsigned char *key, size_t *keylen), (ctx, key, keylen)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_PTR, EVP_MAC_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_CTX_PTR, EVP_MAC_CTX_new, (GO_EVP_MAC_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(void, EVP_MAC_CTX_free, (GO_EVP_MAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_CTX_PTR, EVP_MAC_CTX_dup, (const GO_EVP_MAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(int, EVP_MAC_init, (GO_EVP_MAC_CTX_PTR ctx, const unsigned char *key, size_t keylen, const OSSL_PARAM params[]), (ctx, key, keylen, params)) \
+DEFINEFUNC_3_0(int, EVP_MAC_update, (GO_EVP_MAC_CTX_PTR ctx, const unsigned char *data, size_t datalen), (ctx, data, datalen)) \
+DEFINEFUNC_3_0(int, EVP_MAC_final, (GO_EVP_MAC_CTX_PTR ctx, unsigned char *out, size_t *outl, size_t outsize), (ctx, out, outl, outsize)) \
+DEFINEFUNC_3_0(OSSL_PARAM, OSSL_PARAM_construct_utf8_string, (const char *key, char *buf, size_t bsize), (key, buf, bsize)) \
+DEFINEFUNC_3_0(OSSL_PARAM, OSSL_PARAM_construct_end, (void), ()) \
+
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_lock_setup.c b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_lock_setup.c
new file mode 100644
index 00000000000000..5cd7275f4075ed
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_lock_setup.c
@@ -0,0 +1,53 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+#include "goopenssl.h"
+
+#include <stdio.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+
+#define _GNU_SOURCE
+#include <unistd.h>
+ 
+#define MUTEX_TYPE       pthread_mutex_t
+#define MUTEX_SETUP(x)   pthread_mutex_init(&(x), NULL)
+#define MUTEX_CLEANUP(x) pthread_mutex_destroy(&(x))
+#define MUTEX_LOCK(x)    pthread_mutex_lock(&(x))
+#define MUTEX_UNLOCK(x)  pthread_mutex_unlock(&(x))
+#define THREAD_ID        pthread_self()
+#define CRYPTO_LOCK      0x01
+
+/* This array will store all of the mutexes available to OpenSSL. */ 
+static MUTEX_TYPE *mutex_buf = NULL;
+ 
+static void locking_function(int mode, int n, const char *file, int line)
+{
+  if(mode & CRYPTO_LOCK)
+    MUTEX_LOCK(mutex_buf[n]);
+  else
+    MUTEX_UNLOCK(mutex_buf[n]);
+}
+ 
+static unsigned long id_function(void)
+{
+	return ((unsigned long)syscall(__NR_gettid));
+}
+ 
+int go_openssl_thread_setup(void)
+{
+  int i;
+ 
+  mutex_buf = malloc(go_openssl_CRYPTO_num_locks() * sizeof(MUTEX_TYPE));
+  if(!mutex_buf)
+    return 0;
+  for(i = 0;  i < go_openssl_CRYPTO_num_locks();  i++)
+    MUTEX_SETUP(mutex_buf[i]);
+  go_openssl_CRYPTO_set_id_callback(id_function);
+  go_openssl_CRYPTO_set_locking_callback(locking_function);
+  return 1;
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rand.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rand.go
new file mode 100644
index 00000000000000..17f64a52ae5255
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rand.go
@@ -0,0 +1,24 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import "unsafe"
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) {
+	// Note: RAND_bytes should never fail; the return value exists only for historical reasons.
+	// We check it even so.
+	if len(b) > 0 && C.go_openssl_RAND_bytes((*C.uchar)(unsafe.Pointer(&b[0])), C.int(len(b))) == 0 {
+		return 0, fail("RAND_bytes")
+	}
+	return len(b), nil
+}
+
+const RandReader = randReader(0)
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go
new file mode 100644
index 00000000000000..b717ea932cd8a1
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go
@@ -0,0 +1,337 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"crypto/subtle"
+	"errors"
+	"hash"
+	"runtime"
+	"unsafe"
+)
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+		return nil, nil, nil, nil, nil, nil, nil, nil, e
+	}
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_RSA, bits, "")
+	if err != nil {
+		return bad(err)
+	}
+	defer C.go_openssl_EVP_PKEY_free(pkey)
+	key := C.go_openssl_EVP_PKEY_get1_RSA(pkey)
+	if key == nil {
+		return bad(newOpenSSLError("EVP_PKEY_get1_RSA failed"))
+	}
+	defer C.go_openssl_RSA_free(key)
+	N, E, D = rsaGetKey(key)
+	P, Q = rsaGetFactors(key)
+	Dp, Dq, Qinv = rsaGetCRTParams(key)
+	return
+}
+
+type PublicKeyRSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	key := C.go_openssl_RSA_new()
+	if key == nil {
+		return nil, newOpenSSLError("RSA_new failed")
+	}
+	if !rsaSetKey(key, N, E, nil) {
+		return nil, fail("RSA_set0_key")
+	}
+	pkey := C.go_openssl_EVP_PKEY_new()
+	if pkey == nil {
+		C.go_openssl_RSA_free(key)
+		return nil, newOpenSSLError("EVP_PKEY_new failed")
+	}
+	if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_RSA, (unsafe.Pointer)(key)) != 1 {
+		C.go_openssl_RSA_free(key)
+		C.go_openssl_EVP_PKEY_free(pkey)
+		return nil, newOpenSSLError("EVP_PKEY_assign failed")
+	}
+	k := &PublicKeyRSA{_pkey: pkey}
+	runtime.SetFinalizer(k, (*PublicKeyRSA).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyRSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PublicKeyRSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	// Because of the finalizer, any time _pkey is passed to cgo, that call must
+	// be followed by a call to runtime.KeepAlive, to make sure k is not
+	// collected (and finalized) before the cgo call returns.
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+type PrivateKeyRSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	key := C.go_openssl_RSA_new()
+	if key == nil {
+		return nil, newOpenSSLError("RSA_new failed")
+	}
+	if !rsaSetKey(key, N, E, D) {
+		return nil, fail("RSA_set0_key")
+	}
+	if P != nil && Q != nil {
+		if !rsaSetFactors(key, P, Q) {
+			return nil, fail("RSA_set0_factors")
+		}
+	}
+	if Dp != nil && Dq != nil && Qinv != nil {
+		if !rsaSetCRTParams(key, Dp, Dq, Qinv) {
+			return nil, fail("RSA_set0_crt_params")
+		}
+	}
+	pkey := C.go_openssl_EVP_PKEY_new()
+	if pkey == nil {
+		C.go_openssl_RSA_free(key)
+		return nil, newOpenSSLError("EVP_PKEY_new failed")
+	}
+	if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_RSA, (unsafe.Pointer)(key)) != 1 {
+		C.go_openssl_RSA_free(key)
+		C.go_openssl_EVP_PKEY_free(pkey)
+		return nil, newOpenSSLError("EVP_PKEY_assign failed")
+	}
+	k := &PrivateKeyRSA{_pkey: pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyRSA).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyRSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PrivateKeyRSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	// Because of the finalizer, any time _pkey is passed to cgo, that call must
+	// be followed by a call to runtime.KeepAlive, to make sure k is not
+	// collected (and finalized) before the cgo call returns.
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, nil, label, ciphertext)
+}
+
+func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, nil, label, msg)
+}
+
+func DecryptRSAOAEPWithMGF1Hash(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, ciphertext)
+}
+
+func EncryptRSAOAEPWithMGF1Hash(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, msg)
+}
+
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, ciphertext)
+}
+
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, msg)
+}
+
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	ret, err := evpDecrypt(priv.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, ciphertext)
+	if err != nil {
+		return nil, err
+	}
+	// We could return here, but the Go standard library test expects DecryptRSANoPadding to verify the result
+	// in order to defend against errors in the CRT computation.
+	//
+	// The following code tries to replicate the verification implemented in the upstream function decryptAndCheck, found at
+	// https://github.com/golang/go/blob/9de1ac6ac2cad3871760d0aa288f5ca713afd0a6/src/crypto/rsa/rsa.go#L569-L582.
+	pub := &PublicKeyRSA{_pkey: priv._pkey}
+	// A private EVP_PKEY can be used as a public key as it contains the public information.
+	enc, err := EncryptRSANoPadding(pub, ret)
+	if err != nil {
+		return nil, err
+	}
+	// Upstream does not do a constant time comparison because it works with math/big instead of byte slices,
+	// and math/big does not support constant-time arithmetic yet. See #20654 for more info.
+	if subtle.ConstantTimeCompare(ciphertext, enc) != 1 {
+		return nil, errors.New("rsa: internal error")
+	}
+	return ret, nil
+}
+
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, msg)
+}
+
+func saltLength(saltLen int, sign bool) (C.int, error) {
+	// A salt length of -2 is valid in OpenSSL, but not in crypto/rsa, so reject
+	// it, and lengths < -2, before we convert to the OpenSSL sentinel values.
+	if saltLen <= -2 {
+		return 0, errors.New("crypto/rsa: PSSOptions.SaltLength cannot be negative")
+	}
+	// OpenSSL uses sentinel salt length values like Go crypto does,
+	// but the values don't fully match for rsa.PSSSaltLengthAuto (0).
+	if saltLen == 0 {
+		if sign {
+			if vMajor == 1 {
+				// OpenSSL 1.x uses -2 to mean maximal size when signing where Go crypto uses 0.
+				return C.GO_RSA_PSS_SALTLEN_MAX_SIGN, nil
+			}
+			// OpenSSL 3.x deprecated RSA_PSS_SALTLEN_MAX_SIGN
+			// and uses -3 to mean maximal size when signing where Go crypto uses 0.
+			return C.GO_RSA_PSS_SALTLEN_MAX, nil
+		}
+		// OpenSSL uses -2 to mean auto-detect size when verifying where Go crypto uses 0.
+		return C.GO_RSA_PSS_SALTLEN_AUTO, nil
+	}
+	return C.int(saltLen), nil
+}
+
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	cSaltLen, err := saltLength(saltLen, true)
+	if err != nil {
+		return nil, err
+	}
+	return evpSign(priv.withKey, C.GO_RSA_PKCS1_PSS_PADDING, cSaltLen, h, hashed)
+}
+
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	cSaltLen, err := saltLength(saltLen, false)
+	if err != nil {
+		return err
+	}
+	return evpVerify(pub.withKey, C.GO_RSA_PKCS1_PSS_PADDING, cSaltLen, h, sig, hashed)
+}
+
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	return evpSign(priv.withKey, C.GO_RSA_PKCS1_PADDING, 0, h, hashed)
+}
+
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	if pub.withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {
+		size := C.go_openssl_EVP_PKEY_get_size(pkey)
+		if len(sig) < int(size) {
+			return 0
+		}
+		return 1
+	}) == 0 {
+		return errors.New("crypto/rsa: verification error")
+	}
+	return evpVerify(pub.withKey, C.GO_RSA_PKCS1_PADDING, 0, h, sig, hashed)
+}
+
+// rsa_st_1_0_2 is rsa_st memory layout in OpenSSL 1.0.2.
+type rsa_st_1_0_2 struct {
+	_                C.int
+	_                C.long
+	_                [2]unsafe.Pointer
+	n, e, d          C.GO_BIGNUM_PTR
+	p, q             C.GO_BIGNUM_PTR
+	dmp1, dmq1, iqmp C.GO_BIGNUM_PTR
+	// It contains more fields, but we are not interesed on them.
+}
+
+func bnSet(b1 *C.GO_BIGNUM_PTR, b2 BigInt) {
+	if b2 == nil {
+		return
+	}
+	if *b1 != nil {
+		C.go_openssl_BN_clear_free(*b1)
+	}
+	*b1 = bigToBN(b2)
+}
+
+func rsaSetKey(key C.GO_RSA_PTR, n, e, d BigInt) bool {
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		//r.d and d will be nil for public keys.
+		if (r.n == nil && n == nil) ||
+			(r.e == nil && e == nil) {
+			return false
+		}
+		bnSet(&r.n, n)
+		bnSet(&r.e, e)
+		bnSet(&r.d, d)
+		return true
+	}
+	return C.go_openssl_RSA_set0_key(key, bigToBN(n), bigToBN(e), bigToBN(d)) == 1
+}
+
+func rsaSetFactors(key C.GO_RSA_PTR, p, q BigInt) bool {
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		if (r.p == nil && p == nil) ||
+			(r.q == nil && q == nil) {
+			return false
+		}
+		bnSet(&r.p, p)
+		bnSet(&r.q, q)
+		return true
+	}
+	return C.go_openssl_RSA_set0_factors(key, bigToBN(p), bigToBN(q)) == 1
+}
+
+func rsaSetCRTParams(key C.GO_RSA_PTR, dmp1, dmq1, iqmp BigInt) bool {
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		if (r.dmp1 == nil && dmp1 == nil) ||
+			(r.dmq1 == nil && dmq1 == nil) ||
+			(r.iqmp == nil && iqmp == nil) {
+			return false
+		}
+		bnSet(&r.dmp1, dmp1)
+		bnSet(&r.dmq1, dmq1)
+		bnSet(&r.iqmp, iqmp)
+		return true
+	}
+	return C.go_openssl_RSA_set0_crt_params(key, bigToBN(dmp1), bigToBN(dmq1), bigToBN(iqmp)) == 1
+}
+
+func rsaGetKey(key C.GO_RSA_PTR) (BigInt, BigInt, BigInt) {
+	var n, e, d C.GO_BIGNUM_PTR
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		n, e, d = r.n, r.e, r.d
+	} else {
+		C.go_openssl_RSA_get0_key(key, &n, &e, &d)
+	}
+	return bnToBig(n), bnToBig(e), bnToBig(d)
+}
+
+func rsaGetFactors(key C.GO_RSA_PTR) (BigInt, BigInt) {
+	var p, q C.GO_BIGNUM_PTR
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		p, q = r.p, r.q
+	} else {
+		C.go_openssl_RSA_get0_factors(key, &p, &q)
+	}
+	return bnToBig(p), bnToBig(q)
+}
+
+func rsaGetCRTParams(key C.GO_RSA_PTR) (BigInt, BigInt, BigInt) {
+	var dmp1, dmq1, iqmp C.GO_BIGNUM_PTR
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		dmp1, dmq1, iqmp = r.dmp1, r.dmq1, r.iqmp
+	} else {
+		C.go_openssl_RSA_get0_crt_params(key, &dmp1, &dmq1, &iqmp)
+	}
+	return bnToBig(dmp1), bnToBig(dmq1), bnToBig(iqmp)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go
new file mode 100644
index 00000000000000..12ef875ae0372c
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go
@@ -0,0 +1,600 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"errors"
+	"hash"
+	"runtime"
+	"strconv"
+	"unsafe"
+)
+
+// NOTE: Implementation ported from https://go-review.googlesource.com/c/go/+/404295.
+// The cgo calls in this file are arranged to avoid marking the parameters as escaping.
+// To do that, we call noescape (including via addr).
+// We must also make sure that the data pointer arguments have the form unsafe.Pointer(&...)
+// so that cgo does not annotate them with cgoCheckPointer calls. If it did that, it might look
+// beyond the byte slice and find Go pointers in unprocessed parts of a larger allocation.
+// To do both of these simultaneously, the idiom is unsafe.Pointer(&*addr(p)),
+// where addr returns the base pointer of p, substituting a non-nil pointer for nil,
+// and applying a noescape along the way.
+// This is all to preserve compatibility with the allocation behavior of the non-openssl implementations.
+
+func shaX(md C.GO_EVP_MD_PTR, p []byte, sum []byte) bool {
+	return C.go_shaX(md, unsafe.Pointer(&*addr(p)), C.size_t(len(p)), noescape(unsafe.Pointer(&sum[0]))) != 0
+}
+
+func SHA1(p []byte) (sum [20]byte) {
+	if !shaX(C.go_openssl_EVP_sha1(), p, sum[:]) {
+		panic("openssl: SHA1 failed")
+	}
+	return
+}
+
+func SHA224(p []byte) (sum [28]byte) {
+	if !shaX(C.go_openssl_EVP_sha224(), p, sum[:]) {
+		panic("openssl: SHA224 failed")
+	}
+	return
+}
+
+func SHA256(p []byte) (sum [32]byte) {
+	if !shaX(C.go_openssl_EVP_sha256(), p, sum[:]) {
+		panic("openssl: SHA256 failed")
+	}
+	return
+}
+
+func SHA384(p []byte) (sum [48]byte) {
+	if !shaX(C.go_openssl_EVP_sha384(), p, sum[:]) {
+		panic("openssl: SHA384 failed")
+	}
+	return
+}
+
+func SHA512(p []byte) (sum [64]byte) {
+	if !shaX(C.go_openssl_EVP_sha512(), p, sum[:]) {
+		panic("openssl: SHA512 failed")
+	}
+	return
+}
+
+type evpHash struct {
+	md  C.GO_EVP_MD_PTR
+	ctx C.GO_EVP_MD_CTX_PTR
+	// ctx2 is used in evpHash.sum to avoid changing
+	// the state of ctx. Having it here allows reusing the
+	// same allocated object multiple times.
+	ctx2      C.GO_EVP_MD_CTX_PTR
+	size      int
+	blockSize int
+}
+
+func newEvpHash(ch crypto.Hash, size, blockSize int) *evpHash {
+	md := cryptoHashToMD(ch)
+	if md == nil {
+		panic("openssl: unsupported hash function: " + strconv.Itoa(int(ch)))
+	}
+	ctx := C.go_openssl_EVP_MD_CTX_new()
+	ctx2 := C.go_openssl_EVP_MD_CTX_new()
+	h := &evpHash{
+		md:        md,
+		ctx:       ctx,
+		ctx2:      ctx2,
+		size:      size,
+		blockSize: blockSize,
+	}
+	runtime.SetFinalizer(h, (*evpHash).finalize)
+	h.Reset()
+	return h
+}
+
+func (h *evpHash) finalize() {
+	C.go_openssl_EVP_MD_CTX_free(h.ctx)
+	C.go_openssl_EVP_MD_CTX_free(h.ctx2)
+}
+
+func (h *evpHash) Reset() {
+	// There is no need to reset h.ctx2 because it is always reset after
+	// use in evpHash.sum.
+	if C.go_openssl_EVP_DigestInit(h.ctx, h.md) != 1 {
+		panic("openssl: EVP_DigestInit failed")
+	}
+	runtime.KeepAlive(h)
+}
+
+func (h *evpHash) Write(p []byte) (int, error) {
+	if len(p) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&*addr(p)), C.size_t(len(p))) != 1 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *evpHash) WriteString(s string) (int, error) {
+	// TODO: use unsafe.StringData once we drop support
+	// for go1.19 and earlier.
+	hdr := (*struct {
+		Data *byte
+		Len  int
+	})(unsafe.Pointer(&s))
+	if len(s) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(hdr.Data), C.size_t(len(s))) == 0 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	return len(s), nil
+}
+
+func (h *evpHash) WriteByte(c byte) error {
+	if C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&c), 1) == 0 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	return nil
+}
+
+func (h *evpHash) Size() int {
+	return h.size
+}
+
+func (h *evpHash) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *evpHash) sum(out []byte) {
+	// Make copy of context because Go hash.Hash mandates
+	// that Sum has no effect on the underlying stream.
+	// In particular it is OK to Sum, then Write more, then Sum again,
+	// and the second Sum acts as if the first didn't happen.
+	if C.go_openssl_EVP_MD_CTX_copy(h.ctx2, h.ctx) != 1 {
+		panic("openssl: EVP_MD_CTX_copy failed")
+	}
+	if C.go_openssl_EVP_DigestFinal(h.ctx2, (*C.uchar)(noescape(unsafe.Pointer(base(out)))), nil) != 1 {
+		panic("openssl: EVP_DigestFinal failed")
+	}
+	runtime.KeepAlive(h)
+}
+
+// shaState returns a pointer to the internal sha structure.
+//
+// The EVP_MD_CTX memory layout has changed in OpenSSL 3
+// and the property holding the internal structure is no longer md_data but algctx.
+func (h *evpHash) shaState() unsafe.Pointer {
+	switch vMajor {
+	case 1:
+		// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/crypto/evp/evp_local.h#L12.
+		type mdCtx struct {
+			_       [2]unsafe.Pointer
+			_       C.ulong
+			md_data unsafe.Pointer
+		}
+		return (*mdCtx)(unsafe.Pointer(h.ctx)).md_data
+	case 3:
+		// https://github.com/openssl/openssl/blob/5675a5aaf6a2e489022bcfc18330dae9263e598e/crypto/evp/evp_local.h#L16.
+		type mdCtx struct {
+			_      [3]unsafe.Pointer
+			_      C.ulong
+			_      [3]unsafe.Pointer
+			algctx unsafe.Pointer
+		}
+		return (*mdCtx)(unsafe.Pointer(h.ctx)).algctx
+	default:
+		panic(errUnsuportedVersion())
+	}
+}
+
+// NewSHA1 returns a new SHA1 hash.
+func NewSHA1() hash.Hash {
+	return &sha1Hash{
+		evpHash: newEvpHash(crypto.SHA1, 20, 64),
+	}
+}
+
+type sha1Hash struct {
+	*evpHash
+	out [20]byte
+}
+
+func (h *sha1Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// sha1State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/sha.h#L34.
+type sha1State struct {
+	h      [5]uint32
+	nl, nh uint32
+	x      [64]byte
+	nx     uint32
+}
+
+const (
+	sha1Magic         = "sha\x01"
+	sha1MarshaledSize = len(sha1Magic) + 5*4 + 64 + 8
+)
+
+func (h *sha1Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha1State)(h.shaState())
+	if d == nil {
+		return nil, errors.New("crypto/sha1: can't retrieve hash state")
+	}
+	b := make([]byte, 0, sha1MarshaledSize)
+	b = append(b, sha1Magic...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = appendUint32(b, d.h[4])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *sha1Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(sha1Magic) || string(b[:len(sha1Magic)]) != sha1Magic {
+		return errors.New("crypto/sha1: invalid hash state identifier")
+	}
+	if len(b) != sha1MarshaledSize {
+		return errors.New("crypto/sha1: invalid hash state size")
+	}
+	d := (*sha1State)(h.shaState())
+	if d == nil {
+		return errors.New("crypto/sha1: can't retrieve hash state")
+	}
+	b = b[len(sha1Magic):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b, d.h[4] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+// NewSHA224 returns a new SHA224 hash.
+func NewSHA224() hash.Hash {
+	return &sha224Hash{
+		evpHash: newEvpHash(crypto.SHA224, 224/8, 64),
+	}
+}
+
+type sha224Hash struct {
+	*evpHash
+	out [224 / 8]byte
+}
+
+func (h *sha224Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA256 returns a new SHA256 hash.
+func NewSHA256() hash.Hash {
+	return &sha256Hash{
+		evpHash: newEvpHash(crypto.SHA256, 256/8, 64),
+	}
+}
+
+type sha256Hash struct {
+	*evpHash
+	out [256 / 8]byte
+}
+
+func (h *sha256Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+const (
+	magic224         = "sha\x02"
+	magic256         = "sha\x03"
+	marshaledSize256 = len(magic256) + 8*4 + 64 + 8
+)
+
+// sha256State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/sha.h#L51.
+type sha256State struct {
+	h      [8]uint32
+	nl, nh uint32
+	x      [64]byte
+	nx     uint32
+}
+
+func (h *sha224Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha256State)(h.shaState())
+	if d == nil {
+		return nil, errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize256)
+	b = append(b, magic224...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = appendUint32(b, d.h[4])
+	b = appendUint32(b, d.h[5])
+	b = appendUint32(b, d.h[6])
+	b = appendUint32(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *sha256Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha256State)(h.shaState())
+	if d == nil {
+		return nil, errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize256)
+	b = append(b, magic256...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = appendUint32(b, d.h[4])
+	b = appendUint32(b, d.h[5])
+	b = appendUint32(b, d.h[6])
+	b = appendUint32(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *sha224Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic224) || string(b[:len(magic224)]) != magic224 {
+		return errors.New("crypto/sha256: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize256 {
+		return errors.New("crypto/sha256: invalid hash state size")
+	}
+	d := (*sha256State)(h.shaState())
+	if d == nil {
+		return errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b = b[len(magic224):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b, d.h[4] = consumeUint32(b)
+	b, d.h[5] = consumeUint32(b)
+	b, d.h[6] = consumeUint32(b)
+	b, d.h[7] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+func (h *sha256Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic256) || string(b[:len(magic256)]) != magic256 {
+		return errors.New("crypto/sha256: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize256 {
+		return errors.New("crypto/sha256: invalid hash state size")
+	}
+	d := (*sha256State)(h.shaState())
+	if d == nil {
+		return errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b = b[len(magic256):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b, d.h[4] = consumeUint32(b)
+	b, d.h[5] = consumeUint32(b)
+	b, d.h[6] = consumeUint32(b)
+	b, d.h[7] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+// NewSHA384 returns a new SHA384 hash.
+func NewSHA384() hash.Hash {
+	return &sha384Hash{
+		evpHash: newEvpHash(crypto.SHA384, 384/8, 128),
+	}
+}
+
+type sha384Hash struct {
+	*evpHash
+	out [384 / 8]byte
+}
+
+func (h *sha384Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA512 returns a new SHA512 hash.
+func NewSHA512() hash.Hash {
+	return &sha512Hash{
+		evpHash: newEvpHash(crypto.SHA512, 512/8, 128),
+	}
+}
+
+type sha512Hash struct {
+	*evpHash
+	out [512 / 8]byte
+}
+
+func (h *sha512Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// sha256State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/sha.h#L95.
+type sha512State struct {
+	h      [8]uint64
+	nl, nh uint64
+	x      [128]byte
+	nx     uint32
+}
+
+const (
+	magic384         = "sha\x04"
+	magic512_224     = "sha\x05"
+	magic512_256     = "sha\x06"
+	magic512         = "sha\x07"
+	marshaledSize512 = len(magic512) + 8*8 + 128 + 8
+)
+
+func (h *sha384Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha512State)(h.shaState())
+	if d == nil {
+		return nil, errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize512)
+	b = append(b, magic384...)
+	b = appendUint64(b, d.h[0])
+	b = appendUint64(b, d.h[1])
+	b = appendUint64(b, d.h[2])
+	b = appendUint64(b, d.h[3])
+	b = appendUint64(b, d.h[4])
+	b = appendUint64(b, d.h[5])
+	b = appendUint64(b, d.h[6])
+	b = appendUint64(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, d.nl>>3|d.nh<<61)
+	return b, nil
+}
+
+func (h *sha512Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha512State)(h.shaState())
+	if d == nil {
+		return nil, errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize512)
+	b = append(b, magic512...)
+	b = appendUint64(b, d.h[0])
+	b = appendUint64(b, d.h[1])
+	b = appendUint64(b, d.h[2])
+	b = appendUint64(b, d.h[3])
+	b = appendUint64(b, d.h[4])
+	b = appendUint64(b, d.h[5])
+	b = appendUint64(b, d.h[6])
+	b = appendUint64(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, d.nl>>3|d.nh<<61)
+	return b, nil
+}
+
+func (h *sha384Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic512) {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if string(b[:len(magic384)]) != magic384 {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize512 {
+		return errors.New("crypto/sha512: invalid hash state size")
+	}
+	d := (*sha512State)(h.shaState())
+	if d == nil {
+		return errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b = b[len(magic512):]
+	b, d.h[0] = consumeUint64(b)
+	b, d.h[1] = consumeUint64(b)
+	b, d.h[2] = consumeUint64(b)
+	b, d.h[3] = consumeUint64(b)
+	b, d.h[4] = consumeUint64(b)
+	b, d.h[5] = consumeUint64(b)
+	b, d.h[6] = consumeUint64(b)
+	b, d.h[7] = consumeUint64(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = n << 3
+	d.nh = n >> 61
+	d.nx = uint32(n) % 128
+	return nil
+}
+
+func (h *sha512Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic512) {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if string(b[:len(magic512)]) != magic512 {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize512 {
+		return errors.New("crypto/sha512: invalid hash state size")
+	}
+	d := (*sha512State)(h.shaState())
+	if d == nil {
+		return errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b = b[len(magic512):]
+	b, d.h[0] = consumeUint64(b)
+	b, d.h[1] = consumeUint64(b)
+	b, d.h[2] = consumeUint64(b)
+	b, d.h[3] = consumeUint64(b)
+	b, d.h[4] = consumeUint64(b)
+	b, d.h[5] = consumeUint64(b)
+	b, d.h[6] = consumeUint64(b)
+	b, d.h[7] = consumeUint64(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = n << 3
+	d.nh = n >> 61
+	d.nx = uint32(n) % 128
+	return nil
+}
+
+// appendUint64 appends x into b as a big endian byte sequence.
+func appendUint64(b []byte, x uint64) []byte {
+	return append(b,
+		byte(x>>56),
+		byte(x>>48),
+		byte(x>>40),
+		byte(x>>32),
+		byte(x>>24),
+		byte(x>>16),
+		byte(x>>8),
+		byte(x),
+	)
+}
+
+// appendUint32 appends x into b as a big endian byte sequence.
+func appendUint32(b []byte, x uint32) []byte {
+	return append(b, byte(x>>24), byte(x>>16), byte(x>>8), byte(x))
+}
+
+// consumeUint64 reads a big endian uint64 number from b.
+func consumeUint64(b []byte) ([]byte, uint64) {
+	_ = b[7]
+	x := uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
+		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
+	return b[8:], x
+}
+
+// consumeUint32 reads a big endian uint32 number from b.
+func consumeUint32(b []byte) ([]byte, uint32) {
+	_ = b[3]
+	x := uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
+	return b[4:], x
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/LICENSE b/src/vendor/github.com/microsoft/go-crypto-winnative/LICENSE
new file mode 100644
index 00000000000000..9e841e7a26e4eb
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/LICENSE
@@ -0,0 +1,21 @@
+    MIT License
+
+    Copyright (c) Microsoft Corporation.
+
+    Permission is hereby granted, free of charge, to any person obtaining a copy
+    of this software and associated documentation files (the "Software"), to deal
+    in the Software without restriction, including without limitation the rights
+    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+    copies of the Software, and to permit persons to whom the Software is
+    furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be included in all
+    copies or substantial portions of the Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+    SOFTWARE
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/aes.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/aes.go
new file mode 100644
index 00000000000000..e3b865ab7823d1
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/aes.go
@@ -0,0 +1,359 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"crypto/cipher"
+	"errors"
+	"runtime"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+	"github.com/microsoft/go-crypto-winnative/internal/subtle"
+)
+
+const aesBlockSize = 16
+
+type aesAlgorithm struct {
+	handle            bcrypt.ALG_HANDLE
+	allowedKeyLengths bcrypt.KEY_LENGTHS_STRUCT
+}
+
+func loadAes(mode string) (aesAlgorithm, error) {
+	v, err := loadOrStoreAlg(bcrypt.AES_ALGORITHM, bcrypt.ALG_NONE_FLAG, mode, func(h bcrypt.ALG_HANDLE) (interface{}, error) {
+		// Windows 8 added support to set the CipherMode value on a key,
+		// but Windows 7 requires that it be set on the algorithm before key creation.
+		err := setString(bcrypt.HANDLE(h), bcrypt.CHAINING_MODE, mode)
+		if err != nil {
+			return nil, err
+		}
+		lengths, err := getKeyLengths(bcrypt.HANDLE(h))
+		if err != nil {
+			return nil, err
+		}
+		return aesAlgorithm{h, lengths}, nil
+	})
+	if err != nil {
+		return aesAlgorithm{}, nil
+	}
+	return v.(aesAlgorithm), nil
+}
+
+type aesCipher struct {
+	kh  bcrypt.KEY_HANDLE
+	key []byte
+}
+
+func NewAESCipher(key []byte) (cipher.Block, error) {
+	h, err := loadAes(bcrypt.CHAIN_MODE_ECB)
+	if err != nil {
+		return nil, err
+	}
+	if !keyIsAllowed(h.allowedKeyLengths, uint32(len(key)*8)) {
+		return nil, errors.New("crypto/cipher: invalid key size")
+	}
+	c := &aesCipher{key: make([]byte, len(key))}
+	copy(c.key, key)
+	err = bcrypt.GenerateSymmetricKey(h.handle, &c.kh, nil, c.key, 0)
+	if err != nil {
+		return nil, err
+	}
+	runtime.SetFinalizer(c, (*aesCipher).finalize)
+	return c, nil
+}
+
+func (c *aesCipher) finalize() {
+	bcrypt.DestroyKey(c.kh)
+}
+
+func (c *aesCipher) BlockSize() int { return aesBlockSize }
+
+func (c *aesCipher) Encrypt(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src) < aesBlockSize {
+		panic("crypto/aes: input not full block")
+	}
+	if len(dst) < aesBlockSize {
+		panic("crypto/aes: output not full block")
+	}
+	var ret uint32
+	err := bcrypt.Encrypt(c.kh, src, nil, nil, dst, &ret, 0)
+	if err != nil {
+		panic(err)
+	}
+	if int(ret) != len(src) {
+		panic("crypto/aes: plaintext not fully encrypted")
+	}
+	runtime.KeepAlive(c)
+}
+
+func (c *aesCipher) Decrypt(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src) < aesBlockSize {
+		panic("crypto/aes: input not full block")
+	}
+	if len(dst) < aesBlockSize {
+		panic("crypto/aes: output not full block")
+	}
+
+	var ret uint32
+	err := bcrypt.Decrypt(c.kh, src, nil, nil, dst, &ret, 0)
+	if err != nil {
+		panic(err)
+	}
+	if int(ret) != len(src) {
+		panic("crypto/aes: plaintext not fully decrypted")
+	}
+	runtime.KeepAlive(c)
+}
+
+func (c *aesCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
+	return newCBC(true, c.key, iv)
+}
+
+func (c *aesCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
+	return newCBC(false, c.key, iv)
+}
+
+type noGCM struct {
+	cipher.Block
+}
+
+func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
+	if nonceSize != gcmStandardNonceSize && tagSize != gcmTagSize {
+		return nil, errors.New("crypto/aes: GCM tag and nonce sizes can't be non-standard at the same time")
+	}
+	// Fall back to standard library for GCM with non-standard nonce or tag size.
+	if nonceSize != gcmStandardNonceSize {
+		return cipher.NewGCMWithNonceSize(&noGCM{c}, nonceSize)
+	}
+	if tagSize != gcmTagSize {
+		return cipher.NewGCMWithTagSize(&noGCM{c}, tagSize)
+	}
+	return newGCM(c.key, false)
+}
+
+// NewGCMTLS returns a GCM cipher specific to TLS
+// and should not be used for non-TLS purposes.
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
+	return c.(*aesCipher).NewGCMTLS()
+}
+
+func (c *aesCipher) NewGCMTLS() (cipher.AEAD, error) {
+	return newGCM(c.key, true)
+}
+
+type aesCBC struct {
+	kh      bcrypt.KEY_HANDLE
+	iv      [aesBlockSize]byte
+	encrypt bool
+}
+
+func newCBC(encrypt bool, key, iv []byte) *aesCBC {
+	h, err := loadAes(bcrypt.CHAIN_MODE_CBC)
+	if err != nil {
+		panic(err)
+	}
+	x := &aesCBC{encrypt: encrypt}
+	x.SetIV(iv)
+	err = bcrypt.GenerateSymmetricKey(h.handle, &x.kh, nil, key, 0)
+	if err != nil {
+		panic(err)
+	}
+	runtime.SetFinalizer(x, (*aesCBC).finalize)
+	return x
+}
+
+func (x *aesCBC) finalize() {
+	bcrypt.DestroyKey(x.kh)
+}
+
+func (x *aesCBC) BlockSize() int { return aesBlockSize }
+
+func (x *aesCBC) CryptBlocks(dst, src []byte) {
+	if subtle.InexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src)%aesBlockSize != 0 {
+		panic("crypto/cipher: input not full blocks")
+	}
+	if len(dst) < len(src) {
+		panic("crypto/cipher: output smaller than input")
+	}
+	if len(src) == 0 {
+		return
+	}
+	var ret uint32
+	var err error
+	if x.encrypt {
+		err = bcrypt.Encrypt(x.kh, src, nil, x.iv[:], dst, &ret, 0)
+	} else {
+		err = bcrypt.Decrypt(x.kh, src, nil, x.iv[:], dst, &ret, 0)
+	}
+	if err != nil {
+		panic(err)
+	}
+	if int(ret) != len(src) {
+		panic("crypto/aes: plaintext not fully encrypted")
+	}
+	runtime.KeepAlive(x)
+}
+
+func (x *aesCBC) SetIV(iv []byte) {
+	if len(iv) != aesBlockSize {
+		panic("cipher: incorrect length IV")
+	}
+	copy(x.iv[:], iv)
+}
+
+const (
+	gcmTagSize           = 16
+	gcmStandardNonceSize = 12
+	gcmTlsAddSize        = 13
+	gcmTlsFixedNonceSize = 4
+)
+
+type aesGCM struct {
+	kh           bcrypt.KEY_HANDLE
+	tls          bool
+	minNextNonce uint64
+}
+
+func (g *aesGCM) finalize() {
+	bcrypt.DestroyKey(g.kh)
+}
+
+func newGCM(key []byte, tls bool) (*aesGCM, error) {
+	h, err := loadAes(bcrypt.CHAIN_MODE_GCM)
+	if err != nil {
+		return nil, err
+	}
+	g := &aesGCM{tls: tls}
+	err = bcrypt.GenerateSymmetricKey(h.handle, &g.kh, nil, key, 0)
+	if err != nil {
+		return nil, err
+	}
+	runtime.SetFinalizer(g, (*aesGCM).finalize)
+	return g, nil
+}
+
+func (g *aesGCM) NonceSize() int {
+	return gcmStandardNonceSize
+}
+
+func (g *aesGCM) Overhead() int {
+	return gcmTagSize
+}
+
+func (g *aesGCM) Seal(dst, nonce, plaintext, additionalData []byte) []byte {
+	if len(nonce) != gcmStandardNonceSize {
+		panic("cipher: incorrect nonce length given to GCM")
+	}
+	if uint64(len(plaintext)) > ((1<<32)-2)*aesBlockSize || len(plaintext)+gcmTagSize < len(plaintext) {
+		panic("cipher: message too large for GCM")
+	}
+	if len(dst)+len(plaintext)+gcmTagSize < len(dst) {
+		panic("cipher: message too large for buffer")
+	}
+	if g.tls {
+		if len(additionalData) != gcmTlsAddSize {
+			panic("cipher: incorrect additional data length given to GCM TLS")
+		}
+		// BoringCrypto enforces strictly monotonically increasing explicit nonces
+		// and to fail after 2^64 - 1 keys as per FIPS 140-2 IG A.5,
+		// but BCrypt does not perform this check, so it is implemented here.
+		const maxUint64 = 1<<64 - 1
+		counter := bigUint64(nonce[gcmTlsFixedNonceSize:])
+		if counter == maxUint64 {
+			panic("cipher: nonce counter must be less than 2^64 - 1")
+		}
+		if counter < g.minNextNonce {
+			panic("cipher: nonce counter must be strictly monotonically increasing")
+		}
+		defer func() {
+			g.minNextNonce = counter + 1
+		}()
+	}
+	// Make room in dst to append plaintext+overhead.
+	ret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)
+
+	// Check delayed until now to make sure len(dst) is accurate.
+	if subtle.InexactOverlap(out, plaintext) {
+		panic("cipher: invalid buffer overlap")
+	}
+
+	info := bcrypt.NewAUTHENTICATED_CIPHER_MODE_INFO(nonce, additionalData, out[len(out)-gcmTagSize:])
+	var encSize uint32
+	err := bcrypt.Encrypt(g.kh, plaintext, unsafe.Pointer(info), nil, out, &encSize, 0)
+	if err != nil {
+		panic(err)
+	}
+	if int(encSize) != len(plaintext) {
+		panic("crypto/aes: plaintext not fully encrypted")
+	}
+	runtime.KeepAlive(g)
+	return ret
+}
+
+var errOpen = errors.New("cipher: message authentication failed")
+
+func (g *aesGCM) Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) {
+	if len(nonce) != gcmStandardNonceSize {
+		panic("cipher: incorrect nonce length given to GCM")
+	}
+	if len(ciphertext) < gcmTagSize {
+		return nil, errOpen
+	}
+	if uint64(len(ciphertext)) > ((1<<32)-2)*aesBlockSize+gcmTagSize {
+		return nil, errOpen
+	}
+
+	tag := ciphertext[len(ciphertext)-gcmTagSize:]
+	ciphertext = ciphertext[:len(ciphertext)-gcmTagSize]
+
+	// Make room in dst to append ciphertext without tag.
+	ret, out := sliceForAppend(dst, len(ciphertext))
+
+	// Check delayed until now to make sure len(dst) is accurate.
+	if subtle.InexactOverlap(out, ciphertext) {
+		panic("cipher: invalid buffer overlap")
+	}
+
+	info := bcrypt.NewAUTHENTICATED_CIPHER_MODE_INFO(nonce, additionalData, tag)
+	var decSize uint32
+	err := bcrypt.Decrypt(g.kh, ciphertext, unsafe.Pointer(info), nil, out, &decSize, 0)
+	if err != nil || int(decSize) != len(ciphertext) {
+		for i := range out {
+			out[i] = 0
+		}
+		return nil, errOpen
+	}
+	runtime.KeepAlive(g)
+	return ret, nil
+}
+
+// sliceForAppend is a mirror of crypto/cipher.sliceForAppend.
+func sliceForAppend(in []byte, n int) (head, tail []byte) {
+	if total := len(in) + n; cap(in) >= total {
+		head = in[:total]
+	} else {
+		head = make([]byte, total)
+		copy(head, in)
+	}
+	tail = head[len(in):]
+	return
+}
+
+func bigUint64(b []byte) uint64 {
+	_ = b[7] // bounds check hint to compiler; see go.dev/issue/14808
+	return uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
+		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/bbig/big.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/bbig/big.go
new file mode 100644
index 00000000000000..584f2069b1cd0a
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/bbig/big.go
@@ -0,0 +1,31 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+package bbig
+
+import (
+	"math/big"
+
+	"github.com/microsoft/go-crypto-winnative/cng"
+)
+
+func Enc(b *big.Int) cng.BigInt {
+	if b == nil {
+		return nil
+	}
+	x := b.Bytes()
+	if len(x) == 0 {
+		return cng.BigInt{}
+	}
+	return x
+}
+
+func Dec(b cng.BigInt) *big.Int {
+	if b == nil {
+		return nil
+	}
+	if len(b) == 0 {
+		return new(big.Int)
+	}
+	return new(big.Int).SetBytes(b)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/big.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/big.go
new file mode 100644
index 00000000000000..36f0e0c6e278bc
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/big.go
@@ -0,0 +1,30 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+package cng
+
+import "math/bits"
+
+// This file does not have build constraints to
+// facilitate using BigInt in Go crypto.
+// Go crypto references BigInt unconditionally,
+// even if it is not finally used.
+
+// A BigInt is the big-endian bytes from a math/big BigInt,
+// which are normalized to remove any leading 0 byte.
+// Windows BCrypt accepts this specific data format.
+// This definition allows us to avoid importing math/big.
+// Conversion between BigInt and *big.Int is in cng/bbig.
+type BigInt []byte
+
+const _S = bits.UintSize / 8 // word size in bytes
+
+// Length of x in bits.
+func (x BigInt) bitLen() int {
+	if len(x) == 0 {
+		return 0
+	}
+	// x is normalized, so the length in bits is
+	// the length in bits of x minus one byte (_S),
+	// plus the minimum number of bits to represent the first byte.
+	return (len(x)-1)*_S + bits.Len(uint(x[0]))
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/cng.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/cng.go
new file mode 100644
index 00000000000000..844c087287cabe
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/cng.go
@@ -0,0 +1,130 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"errors"
+	"math"
+	"runtime"
+	"sync"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+func FIPS() (bool, error) {
+	var enabled bool
+	err := bcrypt.GetFipsAlgorithmMode(&enabled)
+	if err != nil {
+		return false, err
+	}
+	return enabled, nil
+}
+
+// len32 clamps s length so it can fit into a Win32 LONG,
+// which is a 32-bit signed integer, without overflowing.
+func len32(s []byte) int {
+	if len(s) > math.MaxInt32 {
+		return math.MaxInt32
+	}
+	return len(s)
+}
+
+var algCache sync.Map
+
+type newAlgEntryFn func(h bcrypt.ALG_HANDLE) (interface{}, error)
+
+func loadOrStoreAlg(id string, flags bcrypt.AlgorithmProviderFlags, mode string, fn newAlgEntryFn) (interface{}, error) {
+	var entryKey = struct {
+		id    string
+		flags bcrypt.AlgorithmProviderFlags
+		mode  string
+	}{id, flags, mode}
+
+	if v, ok := algCache.Load(entryKey); ok {
+		return v, nil
+	}
+	var h bcrypt.ALG_HANDLE
+	err := bcrypt.OpenAlgorithmProvider(&h, utf16PtrFromString(id), nil, flags)
+	if err != nil {
+		return nil, err
+	}
+	v, err := fn(h)
+	if err != nil {
+		bcrypt.CloseAlgorithmProvider(h, 0)
+		return nil, err
+	}
+	if existing, loaded := algCache.LoadOrStore(entryKey, v); loaded {
+		// We can safely use a provider that has already been cached in another concurrent goroutine.
+		bcrypt.CloseAlgorithmProvider(h, 0)
+		v = existing
+	}
+	return v, nil
+}
+
+func utf16PtrFromString(s string) *uint16 {
+	return &utf16FromString(s)[0]
+}
+
+// utf16FromString converts the string using a stack-allocated slice of 64 bytes.
+// It should only be used to convert known BCrypt identifiers which only contains ASCII characters.
+// utf16FromString allocates if s is longer than 31 characters.
+func utf16FromString(s string) []uint16 {
+	// Once https://go.dev/issues/51896 lands and our support matrix allows it,
+	// we can replace part of this function by utf16.AppendRune
+	a := make([]uint16, 0, 32)
+	for _, v := range s {
+		if v == 0 || v > 127 {
+			panic("utf16FromString only supports ASCII characters, got " + s)
+		}
+		a = append(a, uint16(v))
+	}
+	// Finish with a NULL byte.
+	a = append(a, 0)
+	return a
+}
+
+func setString(h bcrypt.HANDLE, name, val string) error {
+	str := utf16FromString(val)
+	defer runtime.KeepAlive(str)
+	// str is a []uint16, which takes 2 bytes per element.
+	n := len(str) * 2
+	in := unsafe.Slice((*byte)(unsafe.Pointer(&str[0])), n)
+	return bcrypt.SetProperty(h, utf16PtrFromString(name), in, 0)
+}
+
+func getUint32(h bcrypt.HANDLE, name string) (uint32, error) {
+	var prop, discard uint32
+	err := bcrypt.GetProperty(h, utf16PtrFromString(name), (*[4]byte)(unsafe.Pointer(&prop))[:], &discard, 0)
+	return prop, err
+}
+
+const sizeOfKEY_LENGTHS_STRUCT = unsafe.Sizeof(bcrypt.KEY_LENGTHS_STRUCT{})
+
+func getKeyLengths(h bcrypt.HANDLE) (lengths bcrypt.KEY_LENGTHS_STRUCT, err error) {
+	var discard uint32
+	ptr := (*[sizeOfKEY_LENGTHS_STRUCT]byte)(unsafe.Pointer(&lengths))
+	err = bcrypt.GetProperty(bcrypt.HANDLE(h), utf16PtrFromString(bcrypt.KEY_LENGTHS), ptr[:], &discard, 0)
+	if err != nil {
+		return
+	}
+	if lengths.MinLength > lengths.MaxLength || (lengths.Increment == 0 && lengths.MinLength != lengths.MaxLength) {
+		err = errors.New("invalid BCRYPT_KEY_LENGTHS_STRUCT")
+		return
+	}
+	return lengths, nil
+}
+
+func keyIsAllowed(lengths bcrypt.KEY_LENGTHS_STRUCT, bits uint32) bool {
+	if bits < lengths.MinLength || bits > lengths.MaxLength {
+		return false
+	}
+	if lengths.Increment == 0 {
+		return bits == lengths.MinLength
+	}
+	return (bits-lengths.MinLength)%lengths.Increment == 0
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdh.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdh.go
new file mode 100644
index 00000000000000..cd6e9a98f6f967
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdh.go
@@ -0,0 +1,260 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"errors"
+	"runtime"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+const ecdhUncompressedPrefix = 4
+
+var errInvalidPublicKey = errors.New("cng: invalid public key")
+var errInvalidPrivateKey = errors.New("cng: invalid private key")
+
+type ecdhAlgorithm struct {
+	handle bcrypt.ALG_HANDLE
+}
+
+func loadECDH(curve string) (h ecdhAlgorithm, bits uint32, err error) {
+	var id string
+	switch curve {
+	case "P-256":
+		id, bits = bcrypt.ECC_CURVE_NISTP256, 256
+	case "P-384":
+		id, bits = bcrypt.ECC_CURVE_NISTP384, 384
+	case "P-521":
+		id, bits = bcrypt.ECC_CURVE_NISTP521, 521
+	case "X25519":
+		id, bits = bcrypt.ECC_CURVE_25519, 255
+	default:
+		err = errUnknownCurve
+	}
+	if err != nil {
+		return
+	}
+	v, err := loadOrStoreAlg(bcrypt.ECDH_ALGORITHM, bcrypt.ALG_NONE_FLAG, id, func(h bcrypt.ALG_HANDLE) (interface{}, error) {
+		err := setString(bcrypt.HANDLE(h), bcrypt.ECC_CURVE_NAME, id)
+		if err != nil {
+			return nil, err
+		}
+		return ecdhAlgorithm{h}, nil
+	})
+	if err != nil {
+		return ecdhAlgorithm{}, 0, err
+	}
+	return v.(ecdhAlgorithm), bits, nil
+}
+
+type PublicKeyECDH struct {
+	hkey  bcrypt.KEY_HANDLE
+	bytes []byte
+
+	// priv is only set when PublicKeyECDH is derived from a private key,
+	// in which case priv's finalizer is responsible for freeing hkey.
+	// This ensures priv is not finalized while the public key is alive,
+	// which could cause use-after-free and double-free behavior.
+	priv *PrivateKeyECDH
+}
+
+func (k *PublicKeyECDH) finalize() {
+	if k.priv == nil {
+		bcrypt.DestroyKey(k.hkey)
+	}
+}
+
+type PrivateKeyECDH struct {
+	hkey   bcrypt.KEY_HANDLE
+	isNIST bool
+}
+
+func (k *PrivateKeyECDH) finalize() {
+	bcrypt.DestroyKey(k.hkey)
+}
+
+func ECDH(priv *PrivateKeyECDH, pub *PublicKeyECDH) ([]byte, error) {
+	// First establish the shared secret.
+	var secret bcrypt.SECRET_HANDLE
+	err := bcrypt.SecretAgreement(priv.hkey, pub.hkey, &secret, 0)
+	if err != nil {
+		return nil, err
+	}
+	defer bcrypt.DestroySecret(secret)
+
+	// Then we need to export the raw shared secret from the secret opaque handler.
+	// The only way to do it is using BCryptDeriveKey with BCRYPT_KDF_RAW_SECRET as key derivation function (KDF).
+	// Unfortunately, this KDF is supported starting from Windows 10.
+	kdf := utf16PtrFromString(bcrypt.KDF_RAW_SECRET)
+	var size uint32
+	err = bcrypt.DeriveKey(secret, kdf, nil, nil, &size, 0)
+	if err != nil {
+		return nil, err
+	}
+	agreedSecret := make([]byte, size)
+	err = bcrypt.DeriveKey(secret, kdf, nil, agreedSecret, &size, 0)
+	if err != nil {
+		return nil, err
+	}
+
+	// The raw shared secret is little-endian but Go expects big-endian.
+	// Reverse the slice in-place.
+	inputMid := size / 2
+	for i := uint32(0); i < inputMid; i++ {
+		j := size - i - 1
+		agreedSecret[i], agreedSecret[j] = agreedSecret[j], agreedSecret[i]
+	}
+	runtime.KeepAlive(priv)
+	runtime.KeepAlive(pub)
+	return agreedSecret, nil
+}
+
+func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
+	h, bits, err := loadECDH(curve)
+	if err != nil {
+		return nil, nil, err
+	}
+	var hkey bcrypt.KEY_HANDLE
+	err = bcrypt.GenerateKeyPair(h.handle, &hkey, bits, 0)
+	if err != nil {
+		return nil, nil, err
+	}
+	// The key cannot be used until BCryptFinalizeKeyPair has been called.
+	err = bcrypt.FinalizeKeyPair(hkey, 0)
+	if err != nil {
+		bcrypt.DestroyKey(hkey)
+		return nil, nil, err
+	}
+
+	// GenerateKeyECDH returns the private key as a byte slice.
+	// To get it we need to export the raw CNG key bytes.
+	hdr, bytes, err := exportECCKey(hkey, true)
+	if err != nil {
+		bcrypt.DestroyKey(hkey)
+		return nil, nil, err
+	}
+	// Only take the private component of the key,
+	// which is the last of the three equally-sized chunks.
+	bytes = bytes[hdr.KeySize*2:]
+
+	k := &PrivateKeyECDH{hkey, isNIST(curve)}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, bytes, nil
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*PublicKeyECDH, error) {
+	// Reject the point at infinity and compressed encodings.
+	// The first byte is always the key encoding.
+	nist := isNIST(curve)
+	if len(bytes) == 0 || (nist && bytes[0] != ecdhUncompressedPrefix) {
+		return nil, errInvalidPublicKey
+	}
+	h, bits, err := loadECDH(curve)
+	if err != nil {
+		return nil, err
+	}
+	// Remove the encoding byte, if any. BCrypt doesn't want it
+	// and it only support uncompressed points anyway.
+	var keyWithoutEncoding []byte
+	var ncomponents int
+	if nist {
+		ncomponents = 2
+		keyWithoutEncoding = bytes[1:]
+	} else {
+		ncomponents = 1
+		keyWithoutEncoding = bytes
+	}
+	keySize := int(bits+7) / 8
+	if len(keyWithoutEncoding) != keySize*ncomponents {
+		return nil, errInvalidPublicKey
+	}
+	hkey, err := importECCKey(h.handle, bcrypt.ECDH_ALGORITHM, bits, keyWithoutEncoding[:keySize], keyWithoutEncoding[keySize:], nil)
+	if err != nil {
+		return nil, err
+	}
+	k := &PublicKeyECDH{hkey, append([]byte(nil), bytes...), nil}
+	runtime.SetFinalizer(k, (*PublicKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyECDH) Bytes() []byte { return k.bytes }
+
+func NewPrivateKeyECDH(curve string, key []byte) (*PrivateKeyECDH, error) {
+	h, bits, err := loadECDH(curve)
+	if err != nil {
+		return nil, err
+	}
+	keySize := int(bits+7) / 8
+	if len(key) != keySize {
+		return nil, errInvalidPrivateKey
+	}
+	nist := isNIST(curve)
+	if !nist {
+		key = convertX25519PrivKey(key)
+	}
+	// CNG allows to import private ECC keys without defining X/Y,
+	// in which case those will be generated from D.
+	// To trigger this behavior we pass a zeroed X/Y with keySize length.
+	// zero is big enough to fit P-521 curves, the largest we handle, in the stack.
+	var zero [(521 + 7) / 8]byte
+	hkey, err := importECCKey(h.handle, bcrypt.ECDH_ALGORITHM, bits, zero[:keySize], zero[:keySize], key)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDH{hkey, nist}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) {
+	defer runtime.KeepAlive(k)
+	hdr, data, err := exportECCKey(k.hkey, false)
+	if err != nil {
+		return nil, err
+	}
+	var bytes []byte
+	if k.isNIST {
+		// Include X and Y.
+		bytes = append([]byte{ecdhUncompressedPrefix}, data...)
+	} else {
+		// Only include X.
+		bytes = data[:hdr.KeySize]
+	}
+	pub := &PublicKeyECDH{k.hkey, bytes, k}
+	runtime.SetFinalizer(pub, (*PublicKeyECDH).finalize)
+	return pub, nil
+}
+
+func isNIST(curve string) bool {
+	return curve != "X25519"
+}
+
+func convertX25519PrivKey(key []byte) []byte {
+	// CNG consume private X25519 keys using a slightly non-standard representation that don't affect the end result.
+	// https://github.com/microsoft/SymCrypt/blob/e875f1f957dcb1308f8e712e9f4a8edc6f4f6207/inc/symcrypt.h#L4670
+	// Go internal X25519 implementation also uses this representation, but a raw private key is also accepted.
+	// https://github.com/golang/go/blob/e246cf626d1768ab56fa9eeafe4d23266e956ef6/src/crypto/ecdh/x25519.go#L90-L92
+
+	// Copy the private key so we don't modify the original.
+	var e [32]byte
+
+	copy(e[:], key[:])
+
+	// Convert to DivHTimesH format by
+	// clearing the last three bits of the least significant byte,
+	// which is the same as applying h*(s/(h mod GOrd)) where
+	// s = key, h = 0x08, GOrd (cbSubgroupOrder) = 0x20.
+	// h and GOrd values taken from
+	// https://github.com/microsoft/SymCrypt/blob/e875f1f957dcb1308f8e712e9f4a8edc6f4f6207/lib/ec_internal_curves.c#L496.
+	e[0] &= 248 // 0b1111_1000
+
+	// Apply the High bit restrictions by clearing the bit 255 and setting the bit 254.
+	e[31] &= 127 // 0b0111_1111
+	e[31] |= 64  // 0b0100_0000
+	return e[:]
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdsa.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdsa.go
new file mode 100644
index 00000000000000..a77ff97bb8f521
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/ecdsa.go
@@ -0,0 +1,175 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"errors"
+	"runtime"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+var errUnknownCurve = errors.New("cng: unknown elliptic curve")
+
+type ecdsaAlgorithm struct {
+	handle bcrypt.ALG_HANDLE
+}
+
+func loadECDSA(curve string) (h ecdsaAlgorithm, bits uint32, err error) {
+	var id string
+	switch curve {
+	case "P-224":
+		id, bits = bcrypt.ECC_CURVE_NISTP224, 224
+	case "P-256":
+		id, bits = bcrypt.ECC_CURVE_NISTP256, 256
+	case "P-384":
+		id, bits = bcrypt.ECC_CURVE_NISTP384, 384
+	case "P-521":
+		id, bits = bcrypt.ECC_CURVE_NISTP521, 521
+	default:
+		err = errUnknownCurve
+	}
+	if err != nil {
+		return
+	}
+	v, err := loadOrStoreAlg(bcrypt.ECDSA_ALGORITHM, bcrypt.ALG_NONE_FLAG, id, func(h bcrypt.ALG_HANDLE) (interface{}, error) {
+		err := setString(bcrypt.HANDLE(h), bcrypt.ECC_CURVE_NAME, id)
+		if err != nil {
+			return nil, err
+		}
+		return ecdsaAlgorithm{h}, nil
+	})
+	if err != nil {
+		return ecdsaAlgorithm{}, 0, err
+	}
+	return v.(ecdsaAlgorithm), bits, nil
+}
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	var h ecdsaAlgorithm
+	var bits uint32
+	h, bits, err = loadECDSA(curve)
+	if err != nil {
+		return
+	}
+	var hkey bcrypt.KEY_HANDLE
+	err = bcrypt.GenerateKeyPair(h.handle, &hkey, bits, 0)
+	if err != nil {
+		return
+	}
+	defer bcrypt.DestroyKey(hkey)
+	// The key cannot be used until BCryptFinalizeKeyPair has been called.
+	err = bcrypt.FinalizeKeyPair(hkey, 0)
+	if err != nil {
+		return
+	}
+	hdr, data, err := exportECCKey(hkey, true)
+	if err != nil {
+		return
+	}
+	consumeBigInt := func(size uint32) BigInt {
+		b := data[:size]
+		data = data[size:]
+		return b
+	}
+	X = consumeBigInt(hdr.KeySize)
+	Y = consumeBigInt(hdr.KeySize)
+	D = consumeBigInt(hdr.KeySize)
+	return
+}
+
+type PublicKeyECDSA struct {
+	hkey bcrypt.KEY_HANDLE
+}
+
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	h, bits, err := loadECDSA(curve)
+	if err != nil {
+		return nil, err
+	}
+	hkey, err := importECCKey(h.handle, bcrypt.ECDSA_ALGORITHM, bits, X, Y, nil)
+	if err != nil {
+		return nil, err
+	}
+	k := &PublicKeyECDSA{hkey}
+	runtime.SetFinalizer(k, (*PublicKeyECDSA).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyECDSA) finalize() {
+	bcrypt.DestroyKey(k.hkey)
+}
+
+type PrivateKeyECDSA struct {
+	hkey bcrypt.KEY_HANDLE
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	h, bits, err := loadECDSA(curve)
+	if err != nil {
+		return nil, err
+	}
+	hkey, err := importECCKey(h.handle, bcrypt.ECDSA_ALGORITHM, bits, X, Y, D)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDSA{hkey}
+	runtime.SetFinalizer(k, (*PrivateKeyECDSA).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyECDSA) finalize() {
+	bcrypt.DestroyKey(k.hkey)
+}
+
+// SignECDSA signs a hash (which should be the result of hashing a larger message),
+// using the private key, priv.
+//
+// We provide this function instead of a boring.SignMarshalECDSA equivalent
+// because BCryptSignHash returns the signature encoded using P1363 instead of ASN.1,
+// so we would have to transform P1363 to ASN.1 using encoding/asn1, which we can't import here,
+// only to be decoded into raw big.Int by the caller.
+func SignECDSA(priv *PrivateKeyECDSA, hash []byte) (r, s BigInt, err error) {
+	defer runtime.KeepAlive(priv)
+	sig, err := keySign(priv.hkey, nil, hash, bcrypt.PAD_UNDEFINED)
+	if err != nil {
+		return nil, nil, err
+	}
+	// BCRYPTSignHash generates ECDSA signatures in P1363 format,
+	// which is simply (r, s), each of them exactly half of the array.
+	if len(sig)%2 != 0 {
+		return nil, nil, errors.New("crypto/ecdsa: invalid signature size from bcrypt")
+	}
+	return sig[:len(sig)/2], sig[len(sig)/2:], nil
+}
+
+// VerifyECDSA verifies the signature in r, s of hash using the public key, pub.
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, r, s BigInt) bool {
+	defer runtime.KeepAlive(pub)
+	sizeBits, err := getUint32(bcrypt.HANDLE(pub.hkey), bcrypt.KEY_LENGTH)
+	if err != nil {
+		return false
+	}
+	size := int(sizeBits+7) / 8
+	// r and s might be shorter than size
+	// if the original big number contained leading zeros,
+	// but they must not be longer than the public key size.
+	if len(r) > size || len(s) > size {
+		return false
+	}
+	sig := make([]byte, 0, size*2)
+	prependZeros := func(nonZeroBytes int) {
+		if zeros := size - nonZeroBytes; zeros > 0 {
+			sig = append(sig, make([]byte, zeros)...)
+		}
+	}
+	prependZeros(len(r))
+	sig = append(sig, r...)
+	prependZeros(len(s))
+	sig = append(sig, s...)
+	return keyVerify(pub.hkey, nil, hash, sig, bcrypt.PAD_UNDEFINED) == nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/hmac.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/hmac.go
new file mode 100644
index 00000000000000..736472d5b4e700
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/hmac.go
@@ -0,0 +1,55 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"hash"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+// hashToID converts a hash.Hash implementation from this package
+// to a CNG hash ID
+func hashToID(h hash.Hash) string {
+	if _, ok := h.(*shaXHash); !ok {
+		return ""
+	}
+	var id string
+	switch h.Size() {
+	case 20:
+		id = bcrypt.SHA1_ALGORITHM
+	case 256 / 8:
+		id = bcrypt.SHA256_ALGORITHM
+	case 384 / 8:
+		id = bcrypt.SHA384_ALGORITHM
+	case 512 / 8:
+		id = bcrypt.SHA512_ALGORITHM
+	}
+	return id
+}
+
+// NewHMAC returns a new HMAC using BCrypt.
+// The function h must return a hash implemented by
+// CNG (for example, h could be cng.NewSHA256).
+// If h is not recognized, NewHMAC returns nil.
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
+	ch := h()
+	id := hashToID(ch)
+	if id == "" {
+		return nil
+	}
+	if len(key) > ch.BlockSize() {
+		// Keys longer than BlockSize are first hashed using
+		// the same hash function, according to RFC 2104, Section 3.
+		// BCrypt already does that, but if we hash the key on our side
+		// we avoid allocating unnecessary memory and
+		// allow keys longer than math.MaxUint32 bytes.
+		ch.Write(key)
+		key = ch.Sum(nil)
+	}
+	return newSHAX(id, bcrypt.ALG_HANDLE_HMAC_FLAG, key)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/keys.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/keys.go
new file mode 100644
index 00000000000000..766768e9d46b41
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/keys.go
@@ -0,0 +1,161 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"errors"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+const (
+	sizeOfECCBlobHeader = uint32(unsafe.Sizeof(bcrypt.ECCKEY_BLOB{}))
+	sizeOfRSABlobHeader = uint32(unsafe.Sizeof(bcrypt.RSAKEY_BLOB{}))
+)
+
+// exportRSAKey exports hkey into a bcrypt.ECCKEY_BLOB header and data.
+func exportECCKey(hkey bcrypt.KEY_HANDLE, private bool) (bcrypt.ECCKEY_BLOB, []byte, error) {
+	var magic string
+	if private {
+		magic = bcrypt.ECCPRIVATE_BLOB
+	} else {
+		magic = bcrypt.ECCPUBLIC_BLOB
+	}
+	blob, err := exportKey(hkey, magic)
+	if err != nil {
+		return bcrypt.ECCKEY_BLOB{}, nil, err
+	}
+	if len(blob) < int(sizeOfECCBlobHeader) {
+		return bcrypt.ECCKEY_BLOB{}, nil, errors.New("cng: exported key is corrupted")
+	}
+	hdr := (*(*bcrypt.ECCKEY_BLOB)(unsafe.Pointer(&blob[0])))
+	return hdr, blob[sizeOfECCBlobHeader:], nil
+}
+
+// exportRSAKey exports hkey into a bcrypt.RSAKEY_BLOB header and data.
+func exportRSAKey(hkey bcrypt.KEY_HANDLE, private bool) (bcrypt.RSAKEY_BLOB, []byte, error) {
+	var magic string
+	if private {
+		magic = bcrypt.RSAFULLPRIVATE_BLOB
+	} else {
+		magic = bcrypt.RSAPUBLIC_KEY_BLOB
+	}
+	blob, err := exportKey(hkey, magic)
+	if err != nil {
+		return bcrypt.RSAKEY_BLOB{}, nil, err
+	}
+	if len(blob) < int(sizeOfRSABlobHeader) {
+		return bcrypt.RSAKEY_BLOB{}, nil, errors.New("cng: exported key is corrupted")
+	}
+	hdr := (*(*bcrypt.RSAKEY_BLOB)(unsafe.Pointer(&blob[0])))
+	return hdr, blob[sizeOfRSABlobHeader:], nil
+}
+
+// exportKey exports hkey to a memory blob.
+func exportKey(hkey bcrypt.KEY_HANDLE, magic string) ([]byte, error) {
+	psBlobType := utf16PtrFromString(magic)
+	var size uint32
+	err := bcrypt.ExportKey(hkey, 0, psBlobType, nil, &size, 0)
+	if err != nil {
+		return nil, err
+	}
+	blob := make([]byte, size)
+	err = bcrypt.ExportKey(hkey, 0, psBlobType, blob, &size, 0)
+	if err != nil {
+		return nil, err
+	}
+	return blob, err
+}
+
+// importECCKey imports a public/private key pair from the given parameters.
+// If D is nil, only the public components will be populated.
+func importECCKey(h bcrypt.ALG_HANDLE, id string, bits uint32, X, Y, D BigInt) (bcrypt.KEY_HANDLE, error) {
+	blob, err := encodeECCKey(id, bits, X, Y, D)
+	if err != nil {
+		return 0, err
+	}
+	var kind string
+	if D == nil {
+		kind = bcrypt.ECCPUBLIC_BLOB
+	} else {
+		kind = bcrypt.ECCPRIVATE_BLOB
+	}
+	var hkey bcrypt.KEY_HANDLE
+	err = bcrypt.ImportKeyPair(h, 0, utf16PtrFromString(kind), &hkey, blob, 0)
+	if err != nil {
+		return 0, err
+	}
+	return hkey, nil
+}
+
+// encodeECCKey generates a bcrypt.ECCKEY_BLOB from the given parameters.
+func encodeECCKey(id string, bits uint32, X, Y, D BigInt) ([]byte, error) {
+	var hdr bcrypt.ECCKEY_BLOB
+	hdr.KeySize = (bits + 7) / 8
+	if len(X) > int(hdr.KeySize) || len(Y) > int(hdr.KeySize) || len(D) > int(hdr.KeySize) {
+		return nil, errors.New("cng: invalid parameters")
+	}
+	switch id {
+	case bcrypt.ECDSA_ALGORITHM:
+		if D == nil {
+			hdr.Magic = bcrypt.ECDSA_PUBLIC_GENERIC_MAGIC
+		} else {
+			hdr.Magic = bcrypt.ECDSA_PRIVATE_GENERIC_MAGIC
+		}
+	case bcrypt.ECDH_ALGORITHM:
+		if D == nil {
+			hdr.Magic = bcrypt.ECDH_PUBLIC_GENERIC_MAGIC
+		} else {
+			hdr.Magic = bcrypt.ECDH_PRIVATE_GENERIC_MAGIC
+		}
+	default:
+		panic("unsupported key ID: " + id)
+	}
+	var blob []byte
+	if D == nil {
+		blob = make([]byte, sizeOfECCBlobHeader+hdr.KeySize*2)
+	} else {
+		blob = make([]byte, sizeOfECCBlobHeader+hdr.KeySize*3)
+	}
+	copy(blob, (*(*[sizeOfECCBlobHeader]byte)(unsafe.Pointer(&hdr)))[:])
+	data := blob[sizeOfECCBlobHeader:]
+	err := encodeBigInt(data, []sizedBigInt{
+		{X, hdr.KeySize}, {Y, hdr.KeySize},
+		{D, hdr.KeySize},
+	})
+	if err != nil {
+		return nil, err
+	}
+	return blob, nil
+}
+
+// sizedBigInt defines a big integer with
+// a size that can be different from the
+// one provided by len(b).
+type sizedBigInt struct {
+	b    BigInt
+	size uint32
+}
+
+// encodeBigInt encodes ints into data.
+// It stops iterating over ints when it finds one nil element.
+func encodeBigInt(data []byte, ints []sizedBigInt) error {
+	for _, v := range ints {
+		if v.b == nil {
+			return nil
+		}
+		// b might be shorter than size if the original big number contained leading zeros.
+		leadingZeros := int(v.size) - len(v.b)
+		if leadingZeros < 0 {
+			return errors.New("cng: invalid parameters")
+		}
+		copy(data[leadingZeros:], v.b)
+		data = data[v.size:]
+	}
+	return nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/rand.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/rand.go
new file mode 100644
index 00000000000000..cdd845ab5bea98
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/rand.go
@@ -0,0 +1,28 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) {
+	if len(b) == 0 {
+		return 0, nil
+	}
+	n := len32(b)
+	const flags = bcrypt.USE_SYSTEM_PREFERRED_RNG
+	err := bcrypt.GenRandom(0, b[:n], flags)
+	if err != nil {
+		return 0, err
+	}
+	return n, nil
+}
+
+const RandReader = randReader(0)
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/rsa.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/rsa.go
new file mode 100644
index 00000000000000..7e3f7abe3487cb
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/rsa.go
@@ -0,0 +1,374 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"crypto"
+	"errors"
+	"hash"
+	"runtime"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+type rsaAlgorithm struct {
+	handle            bcrypt.ALG_HANDLE
+	allowedKeyLengths bcrypt.KEY_LENGTHS_STRUCT
+}
+
+func loadRsa() (rsaAlgorithm, error) {
+	v, err := loadOrStoreAlg(bcrypt.RSA_ALGORITHM, bcrypt.ALG_NONE_FLAG, "", func(h bcrypt.ALG_HANDLE) (interface{}, error) {
+		lengths, err := getKeyLengths(bcrypt.HANDLE(h))
+		if err != nil {
+			return nil, err
+		}
+		return rsaAlgorithm{h, lengths}, nil
+	})
+	if err != nil {
+		return rsaAlgorithm{}, err
+	}
+	return v.(rsaAlgorithm), nil
+}
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+		return nil, nil, nil, nil, nil, nil, nil, nil, e
+	}
+	h, err := loadRsa()
+	if err != nil {
+		return bad(err)
+	}
+	if !keyIsAllowed(h.allowedKeyLengths, uint32(bits)) {
+		return bad(errors.New("crypto/rsa: invalid key size"))
+	}
+	var hkey bcrypt.KEY_HANDLE
+	err = bcrypt.GenerateKeyPair(h.handle, &hkey, uint32(bits), 0)
+	if err != nil {
+		return bad(err)
+	}
+	defer bcrypt.DestroyKey(hkey)
+	// The key cannot be used until BcryptFinalizeKeyPair has been called.
+	err = bcrypt.FinalizeKeyPair(hkey, 0)
+	if err != nil {
+		return bad(err)
+	}
+
+	hdr, data, err := exportRSAKey(hkey, true)
+	if err != nil {
+		return bad(err)
+	}
+	if hdr.Magic != bcrypt.RSAFULLPRIVATE_MAGIC || hdr.BitLength != uint32(bits) {
+		return bad(errors.New("crypto/rsa: exported key is corrupted"))
+	}
+	consumeBigInt := func(size uint32) BigInt {
+		b := data[:size]
+		data = data[size:]
+		return b
+	}
+	E = consumeBigInt(hdr.PublicExpSize)
+	N = consumeBigInt(hdr.ModulusSize)
+	P = consumeBigInt(hdr.Prime1Size)
+	Q = consumeBigInt(hdr.Prime2Size)
+	Dp = consumeBigInt(hdr.Prime1Size)
+	Dq = consumeBigInt(hdr.Prime2Size)
+	Qinv = consumeBigInt(hdr.Prime1Size)
+	D = consumeBigInt(hdr.ModulusSize)
+	return
+}
+
+type PublicKeyRSA struct {
+	hkey bcrypt.KEY_HANDLE
+	bits uint32
+}
+
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	h, err := loadRsa()
+	if err != nil {
+		return nil, err
+	}
+	if !keyIsAllowed(h.allowedKeyLengths, uint32(len(N)*8)) {
+		return nil, errors.New("crypto/rsa: invalid key size")
+	}
+	hkey, err := importRSAKey(h.handle, N, E, nil, nil, nil, nil, nil, nil)
+	if err != nil {
+		return nil, err
+	}
+	k := &PublicKeyRSA{hkey, uint32(N.bitLen())}
+	runtime.SetFinalizer(k, (*PublicKeyRSA).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyRSA) finalize() {
+	bcrypt.DestroyKey(k.hkey)
+}
+
+type PrivateKeyRSA struct {
+	hkey bcrypt.KEY_HANDLE
+	bits uint32
+}
+
+func (k *PrivateKeyRSA) finalize() {
+	bcrypt.DestroyKey(k.hkey)
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	h, err := loadRsa()
+	if err != nil {
+		return nil, err
+	}
+	if !keyIsAllowed(h.allowedKeyLengths, uint32(len(N)*8)) {
+		return nil, errors.New("crypto/rsa: invalid key size")
+	}
+	hkey, err := importRSAKey(h.handle, N, E, D, P, Q, Dp, Dq, Qinv)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyRSA{hkey, uint32(N.bitLen())}
+	runtime.SetFinalizer(k, (*PrivateKeyRSA).finalize)
+	return k, nil
+}
+
+func importRSAKey(h bcrypt.ALG_HANDLE, N, E, D, P, Q, Dp, Dq, Qinv BigInt) (bcrypt.KEY_HANDLE, error) {
+	blob, err := encodeRSAKey(N, E, D, P, Q, Dp, Dq, Qinv)
+	if err != nil {
+		return 0, err
+	}
+	var kind string
+	if D == nil {
+		kind = bcrypt.RSAPUBLIC_KEY_BLOB
+	} else {
+		kind = bcrypt.RSAFULLPRIVATE_BLOB
+	}
+	var hkey bcrypt.KEY_HANDLE
+	err = bcrypt.ImportKeyPair(h, 0, utf16PtrFromString(kind), &hkey, blob, 0)
+	if err != nil {
+		return 0, err
+	}
+	return hkey, nil
+}
+
+func encodeRSAKey(N, E, D, P, Q, Dp, Dq, Qinv BigInt) ([]byte, error) {
+	hdr := bcrypt.RSAKEY_BLOB{
+		BitLength:     uint32(len(N) * 8),
+		PublicExpSize: uint32(len(E)),
+		ModulusSize:   uint32(len(N)),
+	}
+	var blob []byte
+	if D == nil {
+		hdr.Magic = bcrypt.RSAPUBLIC_MAGIC
+		blob = make([]byte, sizeOfRSABlobHeader+hdr.PublicExpSize+hdr.ModulusSize)
+	} else {
+		if P == nil || Q == nil {
+			// This case can happen when the key has been generated with more than 2 primes.
+			// CNG only supports 2-prime keys.
+			return nil, errors.New("crypto/rsa: unsupported private key")
+		}
+		hdr.Magic = bcrypt.RSAFULLPRIVATE_MAGIC
+		hdr.Prime1Size = uint32(len(P))
+		hdr.Prime2Size = uint32(len(Q))
+		blob = make([]byte, sizeOfRSABlobHeader+hdr.PublicExpSize+hdr.ModulusSize*2+hdr.Prime1Size*3+hdr.Prime2Size*2)
+	}
+	copy(blob, (*(*[sizeOfRSABlobHeader]byte)(unsafe.Pointer(&hdr)))[:])
+	data := blob[sizeOfRSABlobHeader:]
+	err := encodeBigInt(data, []sizedBigInt{
+		{E, hdr.PublicExpSize}, {N, hdr.ModulusSize},
+		{P, hdr.Prime1Size}, {Q, hdr.Prime2Size},
+		{Dp, hdr.Prime1Size}, {Dq, hdr.Prime2Size},
+		{Qinv, hdr.Prime1Size}, {D, hdr.ModulusSize},
+	})
+	if err != nil {
+		return nil, err
+	}
+	return blob, nil
+}
+
+func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	return rsaOAEP(h, priv.hkey, ciphertext, label, false)
+}
+
+func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	defer runtime.KeepAlive(pub)
+	return rsaOAEP(h, pub.hkey, msg, label, true)
+}
+
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	return rsaCrypt(priv.hkey, nil, ciphertext, bcrypt.PAD_PKCS1, false)
+}
+
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	defer runtime.KeepAlive(pub)
+	return rsaCrypt(pub.hkey, nil, msg, bcrypt.PAD_PKCS1, true)
+}
+
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	return rsaCrypt(priv.hkey, nil, ciphertext, bcrypt.PAD_NONE, false)
+
+}
+
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	defer runtime.KeepAlive(pub)
+	return rsaCrypt(pub.hkey, nil, msg, bcrypt.PAD_NONE, true)
+}
+
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	info, err := newPSS_PADDING_INFO(h, priv.bits, saltLen, true)
+	if err != nil {
+		return nil, err
+	}
+	return keySign(priv.hkey, unsafe.Pointer(&info), hashed, bcrypt.PAD_PSS)
+}
+
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	defer runtime.KeepAlive(pub)
+	info, err := newPSS_PADDING_INFO(h, pub.bits, saltLen, false)
+	if err != nil {
+		return err
+	}
+	return keyVerify(pub.hkey, unsafe.Pointer(&info), hashed, sig, bcrypt.PAD_PSS)
+}
+
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	info, err := newPKCS1_PADDING_INFO(h)
+	if err != nil {
+		return nil, err
+	}
+	return keySign(priv.hkey, unsafe.Pointer(&info), hashed, bcrypt.PAD_PKCS1)
+}
+
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	defer runtime.KeepAlive(pub)
+	info, err := newPKCS1_PADDING_INFO(h)
+	if err != nil {
+		return err
+	}
+	return keyVerify(pub.hkey, unsafe.Pointer(&info), hashed, sig, bcrypt.PAD_PKCS1)
+}
+
+func rsaCrypt(pkey bcrypt.KEY_HANDLE, info unsafe.Pointer, in []byte, flags bcrypt.PadMode, encrypt bool) ([]byte, error) {
+	var size uint32
+	var err error
+	if encrypt {
+		err = bcrypt.Encrypt(pkey, in, info, nil, nil, &size, flags)
+	} else {
+		err = bcrypt.Decrypt(pkey, in, info, nil, nil, &size, flags)
+	}
+	if err != nil {
+		return nil, err
+	}
+	out := make([]byte, size)
+	if encrypt {
+		err = bcrypt.Encrypt(pkey, in, info, nil, out, &size, flags)
+	} else {
+		err = bcrypt.Decrypt(pkey, in, info, nil, out, &size, flags)
+	}
+	if err != nil {
+		return nil, err
+	}
+	return out[:size], nil
+}
+
+func rsaOAEP(h hash.Hash, pkey bcrypt.KEY_HANDLE, in, label []byte, encrypt bool) ([]byte, error) {
+	hashID := hashToID(h)
+	if hashID == "" {
+		return nil, errors.New("crypto/rsa: unsupported hash function")
+	}
+	info := bcrypt.OAEP_PADDING_INFO{
+		AlgId:     utf16PtrFromString(hashID),
+		LabelSize: uint32(len(label)),
+	}
+	if len(label) > 0 {
+		info.Label = &label[0]
+	}
+	return rsaCrypt(pkey, unsafe.Pointer(&info), in, bcrypt.PAD_OAEP, encrypt)
+}
+
+func keySign(pkey bcrypt.KEY_HANDLE, info unsafe.Pointer, hashed []byte, flags bcrypt.PadMode) ([]byte, error) {
+	var size uint32
+	err := bcrypt.SignHash(pkey, info, hashed, nil, &size, flags)
+	if err != nil {
+		return nil, err
+	}
+	out := make([]byte, size)
+	err = bcrypt.SignHash(pkey, info, hashed, out, &size, flags)
+	if err != nil {
+		return nil, err
+	}
+	return out[:size], nil
+}
+
+func keyVerify(pkey bcrypt.KEY_HANDLE, info unsafe.Pointer, hashed, sig []byte, flags bcrypt.PadMode) error {
+	return bcrypt.VerifySignature(pkey, info, hashed, sig, flags)
+}
+
+func newPSS_PADDING_INFO(h crypto.Hash, sizeBits uint32, saltLen int, sign bool) (info bcrypt.PSS_PADDING_INFO, err error) {
+	hashID := cryptoHashToID(h)
+	if hashID == "" {
+		return info, errors.New("crypto/rsa: unsupported hash function")
+	}
+	info.AlgId = utf16PtrFromString(hashID)
+
+	// A salt length of -1 and 0 are valid Go sentinel values.
+	if saltLen <= -2 {
+		return info, errors.New("crypto/rsa: PSSOptions.SaltLength cannot be negative")
+	}
+	// CNG does not support salt length special cases like Go crypto does,
+	// so we do a best-effort to resolve them.
+	switch saltLen {
+	case -1: // rsa.PSSSaltLengthEqualsHash
+		info.Salt = uint32(h.Size())
+	case 0: // rsa.PSSSaltLengthAuto
+		if sign {
+			// Algorithm taken from RFC 3447 Section 9.1.1, which is also implemented by Go at
+			// https://github.com/golang/go/blob/54182ff54a687272dd7632c3a963e036ce03cb7c/src/crypto/rsa/pss.go#L288.
+			emLen := (sizeBits - 1 + 7) / 8
+			hLen := uint32(h.Size())
+			info.Salt = emLen - hLen - 2
+		} else {
+			// Go auto-detects the salt length from the signature structure when verifying.
+			// The auto-detection logic is deep in the verification process,
+			// we can't replicate it without exhaustive validation.
+			err = errors.New("crypto/rsa: rsa.PSSSaltLengthAuto not supported")
+		}
+	default:
+		info.Salt = uint32(saltLen)
+	}
+	return
+}
+
+func newPKCS1_PADDING_INFO(h crypto.Hash) (info bcrypt.PKCS1_PADDING_INFO, err error) {
+	if h != 0 {
+		hashID := cryptoHashToID(h)
+		if hashID == "" {
+			err = errors.New("crypto/rsa: unsupported hash function")
+		} else {
+			info.AlgId = utf16PtrFromString(hashID)
+		}
+	}
+	return
+}
+
+func cryptoHashToID(ch crypto.Hash) string {
+	switch ch {
+	case crypto.MD5:
+		return bcrypt.MD5_ALGORITHM
+	case crypto.SHA1:
+		return bcrypt.SHA1_ALGORITHM
+	case crypto.SHA256:
+		return bcrypt.SHA256_ALGORITHM
+	case crypto.SHA384:
+		return bcrypt.SHA384_ALGORITHM
+	case crypto.SHA512:
+		return bcrypt.SHA512_ALGORITHM
+	}
+	return ""
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/cng/sha.go b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/sha.go
new file mode 100644
index 00000000000000..1f5356c9387fc6
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/cng/sha.go
@@ -0,0 +1,219 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build windows
+// +build windows
+
+package cng
+
+import (
+	"hash"
+	"runtime"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/internal/bcrypt"
+)
+
+func shaOneShot(id string, p, sum []byte) error {
+	h, err := loadSha(id, 0)
+	if err != nil {
+		return err
+	}
+	return bcrypt.Hash(h.handle, nil, p, sum)
+}
+
+func SHA1(p []byte) (sum [20]byte) {
+	if err := shaOneShot(bcrypt.SHA1_ALGORITHM, p, sum[:]); err != nil {
+		panic("bcrypt: SHA1 failed")
+	}
+	return
+}
+
+func SHA256(p []byte) (sum [32]byte) {
+	if err := shaOneShot(bcrypt.SHA256_ALGORITHM, p, sum[:]); err != nil {
+		panic("bcrypt: SHA256 failed")
+	}
+	return
+}
+
+func SHA384(p []byte) (sum [48]byte) {
+	if err := shaOneShot(bcrypt.SHA384_ALGORITHM, p, sum[:]); err != nil {
+		panic("bcrypt: SHA384 failed")
+	}
+	return
+}
+
+func SHA512(p []byte) (sum [64]byte) {
+	if err := shaOneShot(bcrypt.SHA512_ALGORITHM, p, sum[:]); err != nil {
+		panic("bcrypt: SHA512 failed")
+	}
+	return
+}
+
+// NewSHA1 returns a new SHA1 hash.
+func NewSHA1() hash.Hash {
+	return newSHAX(bcrypt.SHA1_ALGORITHM, bcrypt.ALG_NONE_FLAG, nil)
+}
+
+// NewSHA256 returns a new SHA256 hash.
+func NewSHA256() hash.Hash {
+	return newSHAX(bcrypt.SHA256_ALGORITHM, bcrypt.ALG_NONE_FLAG, nil)
+}
+
+// NewSHA384 returns a new SHA384 hash.
+func NewSHA384() hash.Hash {
+	return newSHAX(bcrypt.SHA384_ALGORITHM, bcrypt.ALG_NONE_FLAG, nil)
+}
+
+// NewSHA512 returns a new SHA512 hash.
+func NewSHA512() hash.Hash {
+	return newSHAX(bcrypt.SHA512_ALGORITHM, bcrypt.ALG_NONE_FLAG, nil)
+}
+
+type shaAlgorithm struct {
+	handle    bcrypt.ALG_HANDLE
+	size      uint32
+	blockSize uint32
+}
+
+func loadSha(id string, flags bcrypt.AlgorithmProviderFlags) (shaAlgorithm, error) {
+	v, err := loadOrStoreAlg(id, flags, "", func(h bcrypt.ALG_HANDLE) (interface{}, error) {
+		size, err := getUint32(bcrypt.HANDLE(h), bcrypt.HASH_LENGTH)
+		if err != nil {
+			return nil, err
+		}
+		blockSize, err := getUint32(bcrypt.HANDLE(h), bcrypt.HASH_BLOCK_LENGTH)
+		if err != nil {
+			return nil, err
+		}
+		return shaAlgorithm{h, size, blockSize}, nil
+	})
+	if err != nil {
+		return shaAlgorithm{}, err
+	}
+	return v.(shaAlgorithm), nil
+}
+
+type shaXHash struct {
+	h         bcrypt.ALG_HANDLE
+	ctx       bcrypt.HASH_HANDLE
+	size      int
+	blockSize int
+	buf       []byte
+	key       []byte
+}
+
+func newSHAX(id string, flag bcrypt.AlgorithmProviderFlags, key []byte) *shaXHash {
+	h, err := loadSha(id, flag)
+	if err != nil {
+		panic(err)
+	}
+	sha := new(shaXHash)
+	sha.h = h.handle
+	sha.size = int(h.size)
+	sha.blockSize = int(h.blockSize)
+	sha.buf = make([]byte, sha.size)
+	if len(key) > 0 {
+		sha.key = make([]byte, len(key))
+		copy(sha.key, key)
+	}
+	sha.Reset()
+	runtime.SetFinalizer(sha, (*shaXHash).finalize)
+	return sha
+}
+
+func (h *shaXHash) finalize() {
+	if h.ctx != 0 {
+		bcrypt.DestroyHash(h.ctx)
+	}
+}
+
+func (h *shaXHash) Clone() (hash.Hash, error) {
+	h2 := &shaXHash{
+		h:         h.h,
+		size:      h.size,
+		blockSize: h.blockSize,
+		buf:       make([]byte, len(h.buf)),
+		key:       make([]byte, len(h.key)),
+	}
+	copy(h2.key, h.key)
+	err := bcrypt.DuplicateHash(h.ctx, &h2.ctx, nil, 0)
+	if err != nil {
+		return nil, err
+	}
+	runtime.SetFinalizer(h2, (*shaXHash).finalize)
+	runtime.KeepAlive(h)
+	return h2, nil
+}
+
+func (h *shaXHash) Reset() {
+	if h.ctx != 0 {
+		bcrypt.DestroyHash(h.ctx)
+		h.ctx = 0
+	}
+	err := bcrypt.CreateHash(h.h, &h.ctx, nil, h.key, 0)
+	if err != nil {
+		panic(err)
+	}
+	runtime.KeepAlive(h)
+}
+
+func (h *shaXHash) Write(p []byte) (n int, err error) {
+	for n < len(p) && err == nil {
+		nn := len32(p[n:])
+		err = bcrypt.HashData(h.ctx, p[n:n+nn], 0)
+		n += nn
+	}
+	if err != nil {
+		// hash.Hash interface mandates Write should never return an error.
+		panic(err)
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *shaXHash) WriteString(s string) (int, error) {
+	// TODO: use unsafe.StringData once we drop support
+	// for go1.19 and earlier.
+	hdr := (*struct {
+		Data *byte
+		Len  int
+	})(unsafe.Pointer(&s))
+	return h.Write(unsafe.Slice(hdr.Data, len(s)))
+}
+
+func (h *shaXHash) WriteByte(c byte) error {
+	if err := bcrypt.HashDataRaw(h.ctx, &c, 1, 0); err != nil {
+		// hash.Hash interface mandates Write should never return an error.
+		panic(err)
+	}
+	runtime.KeepAlive(h)
+	return nil
+}
+
+func (h *shaXHash) Size() int {
+	return h.size
+}
+
+func (h *shaXHash) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *shaXHash) Sum(in []byte) []byte {
+	h.sum(h.buf)
+	return append(in, h.buf...)
+}
+
+func (h *shaXHash) sum(out []byte) {
+	var ctx2 bcrypt.HASH_HANDLE
+	err := bcrypt.DuplicateHash(h.ctx, &ctx2, nil, 0)
+	if err != nil {
+		panic(err)
+	}
+	defer bcrypt.DestroyHash(ctx2)
+	err = bcrypt.FinishHash(ctx2, out, 0)
+	if err != nil {
+		panic(err)
+	}
+	runtime.KeepAlive(h)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/bcrypt_windows.go b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/bcrypt_windows.go
new file mode 100644
index 00000000000000..d5f6c99a444b85
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/bcrypt_windows.go
@@ -0,0 +1,222 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:generate go run github.com/microsoft/go-crypto-winnative/cmd/mksyscall -output zsyscall_windows.go bcrypt_windows.go
+
+package bcrypt
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+const (
+	SHA1_ALGORITHM   = "SHA1"
+	SHA256_ALGORITHM = "SHA256"
+	SHA384_ALGORITHM = "SHA384"
+	SHA512_ALGORITHM = "SHA512"
+	AES_ALGORITHM    = "AES"
+	RSA_ALGORITHM    = "RSA"
+	MD5_ALGORITHM    = "MD5"
+	ECDSA_ALGORITHM  = "ECDSA"
+	ECDH_ALGORITHM   = "ECDH"
+)
+
+const (
+	ECC_CURVE_25519    = "curve25519"
+	ECC_CURVE_NISTP224 = "nistP224"
+	ECC_CURVE_NISTP256 = "nistP256"
+	ECC_CURVE_NISTP384 = "nistP384"
+	ECC_CURVE_NISTP521 = "nistP521"
+)
+
+const (
+	HASH_LENGTH       = "HashDigestLength"
+	HASH_BLOCK_LENGTH = "HashBlockLength"
+	CHAINING_MODE     = "ChainingMode"
+	CHAIN_MODE_ECB    = "ChainingModeECB"
+	CHAIN_MODE_CBC    = "ChainingModeCBC"
+	CHAIN_MODE_GCM    = "ChainingModeGCM"
+	KEY_LENGTH        = "KeyLength"
+	KEY_LENGTHS       = "KeyLengths"
+	BLOCK_LENGTH      = "BlockLength"
+	ECC_CURVE_NAME    = "ECCCurveName"
+)
+
+const (
+	RSAPUBLIC_KEY_BLOB  = "RSAPUBLICBLOB"
+	RSAFULLPRIVATE_BLOB = "RSAFULLPRIVATEBLOB"
+	ECCPUBLIC_BLOB      = "ECCPUBLICBLOB"
+	ECCPRIVATE_BLOB     = "ECCPRIVATEBLOB"
+)
+
+const (
+	USE_SYSTEM_PREFERRED_RNG = 0x00000002
+)
+
+const (
+	KDF_RAW_SECRET = "TRUNCATE"
+)
+
+type PadMode uint32
+
+const (
+	PAD_UNDEFINED PadMode = 0x0
+	PAD_NONE      PadMode = 0x1
+	PAD_PKCS1     PadMode = 0x2
+	PAD_OAEP      PadMode = 0x4
+	PAD_PSS       PadMode = 0x8
+)
+
+type AlgorithmProviderFlags uint32
+
+const (
+	ALG_NONE_FLAG        AlgorithmProviderFlags = 0x00000000
+	ALG_HANDLE_HMAC_FLAG AlgorithmProviderFlags = 0x00000008
+)
+
+type KeyBlobMagicNumber uint32
+
+const (
+	RSAPUBLIC_MAGIC      KeyBlobMagicNumber = 0x31415352
+	RSAFULLPRIVATE_MAGIC KeyBlobMagicNumber = 0x33415352
+
+	ECDSA_PUBLIC_GENERIC_MAGIC  KeyBlobMagicNumber = 0x50444345
+	ECDSA_PRIVATE_GENERIC_MAGIC KeyBlobMagicNumber = 0x56444345
+
+	ECDH_PUBLIC_GENERIC_MAGIC  KeyBlobMagicNumber = 0x504B4345
+	ECDH_PRIVATE_GENERIC_MAGIC KeyBlobMagicNumber = 0x564B4345
+)
+
+type (
+	HANDLE        syscall.Handle
+	ALG_HANDLE    HANDLE
+	HASH_HANDLE   HANDLE
+	KEY_HANDLE    HANDLE
+	SECRET_HANDLE HANDLE
+)
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_key_lengths_struct
+type KEY_LENGTHS_STRUCT struct {
+	MinLength uint32
+	MaxLength uint32
+	Increment uint32
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_authenticated_cipher_mode_info
+type AUTHENTICATED_CIPHER_MODE_INFO struct {
+	Size           uint32
+	InfoVersion    uint32
+	Nonce          *byte
+	NonceSize      uint32
+	AuthData       *byte
+	AuthDataSize   uint32
+	Tag            *byte
+	TagSize        uint32
+	MacContext     *byte
+	MacContextSize uint32
+	AADSize        uint32
+	DataSize       uint64
+	Flags          uint32
+}
+
+func NewAUTHENTICATED_CIPHER_MODE_INFO(nonce, additionalData, tag []byte) *AUTHENTICATED_CIPHER_MODE_INFO {
+	var aad *byte
+	if len(additionalData) > 0 {
+		aad = &additionalData[0]
+	}
+	info := AUTHENTICATED_CIPHER_MODE_INFO{
+		InfoVersion:  1,
+		Nonce:        &nonce[0],
+		NonceSize:    uint32(len(nonce)),
+		AuthData:     aad,
+		AuthDataSize: uint32(len(additionalData)),
+		Tag:          &tag[0],
+		TagSize:      uint32(len(tag)),
+	}
+	info.Size = uint32(unsafe.Sizeof(info))
+	return &info
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_oaep_padding_info
+type OAEP_PADDING_INFO struct {
+	AlgId     *uint16
+	Label     *byte
+	LabelSize uint32
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_pkcs1_padding_info
+type PKCS1_PADDING_INFO struct {
+	AlgId *uint16
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_pss_padding_info
+type PSS_PADDING_INFO struct {
+	AlgId *uint16
+	Salt  uint32
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_rsakey_blob
+type RSAKEY_BLOB struct {
+	Magic         KeyBlobMagicNumber
+	BitLength     uint32
+	PublicExpSize uint32
+	ModulusSize   uint32
+	Prime1Size    uint32
+	Prime2Size    uint32
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_ecckey_blob
+type ECCKEY_BLOB struct {
+	Magic   KeyBlobMagicNumber
+	KeySize uint32
+}
+
+func Encrypt(hKey KEY_HANDLE, plaintext []byte, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
+	var pInput *byte
+	if len(plaintext) > 0 {
+		pInput = &plaintext[0]
+	} else {
+		// BCryptEncrypt does not support nil plaintext.
+		// Allocate a zero byte here just to make CNG happy.
+		// It won't be encrypted anyway because the plaintext length is zero.
+		pInput = new(byte)
+	}
+	return _Encrypt(hKey, pInput, uint32(len(plaintext)), pPaddingInfo, pbIV, pbOutput, pcbResult, dwFlags)
+}
+
+//sys	GetFipsAlgorithmMode(enabled *bool) (s error) = bcrypt.BCryptGetFipsAlgorithmMode
+//sys	SetProperty(hObject HANDLE, pszProperty *uint16, pbInput []byte, dwFlags uint32) (s error) = bcrypt.BCryptSetProperty
+//sys	GetProperty(hObject HANDLE, pszProperty *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) = bcrypt.BCryptGetProperty
+//sys	OpenAlgorithmProvider(phAlgorithm *ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, dwFlags AlgorithmProviderFlags) (s error) = bcrypt.BCryptOpenAlgorithmProvider
+//sys	CloseAlgorithmProvider(hAlgorithm ALG_HANDLE, dwFlags uint32) (s error) = bcrypt.BCryptCloseAlgorithmProvider
+
+// SHA and HMAC
+
+//sys	Hash(hAlgorithm ALG_HANDLE, pbSecret []byte, pbInput []byte, pbOutput []byte) (s error) = bcrypt.BCryptHash
+//sys	CreateHash(hAlgorithm ALG_HANDLE, phHash *HASH_HANDLE, pbHashObject []byte, pbSecret []byte, dwFlags uint32) (s error) = bcrypt.BCryptCreateHash
+//sys	DestroyHash(hHash HASH_HANDLE) (s error) = bcrypt.BCryptDestroyHash
+//sys   HashData(hHash HASH_HANDLE, pbInput []byte, dwFlags uint32) (s error) = bcrypt.BCryptHashData
+//sys   HashDataRaw(hHash HASH_HANDLE, pbInput *byte, cbInput uint32, dwFlags uint32) (s error) = bcrypt.BCryptHashData
+//sys   DuplicateHash(hHash HASH_HANDLE,  phNewHash *HASH_HANDLE, pbHashObject []byte, dwFlags uint32) (s error) = bcrypt.BCryptDuplicateHash
+//sys   FinishHash(hHash HASH_HANDLE, pbOutput []byte, dwFlags uint32) (s error) = bcrypt.BCryptFinishHash
+
+// Rand
+
+//sys   GenRandom(hAlgorithm ALG_HANDLE, pbBuffer []byte, dwFlags uint32) (s error) = bcrypt.BCryptGenRandom
+
+// Keys
+
+//sys   GenerateSymmetricKey(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, pbKeyObject []byte, pbSecret []byte, dwFlags uint32) (s error) = bcrypt.BCryptGenerateSymmetricKey
+//sys   GenerateKeyPair(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, dwLength uint32, dwFlags uint32) (s error) = bcrypt.BCryptGenerateKeyPair
+//sys   FinalizeKeyPair(hKey KEY_HANDLE, dwFlags uint32) (s error) = bcrypt.BCryptFinalizeKeyPair
+//sys   ImportKeyPair (hAlgorithm ALG_HANDLE, hImportKey KEY_HANDLE, pszBlobType *uint16, phKey *KEY_HANDLE, pbInput []byte, dwFlags uint32) (s error) = bcrypt.BCryptImportKeyPair
+//sys   ExportKey(hKey KEY_HANDLE, hExportKey KEY_HANDLE, pszBlobType *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) = bcrypt.BCryptExportKey
+//sys   DestroyKey(hKey KEY_HANDLE) (s error) = bcrypt.BCryptDestroyKey
+//sys   _Encrypt(hKey KEY_HANDLE, pbInput *byte, cbInput uint32, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) = bcrypt.BCryptEncrypt
+//sys   Decrypt(hKey KEY_HANDLE, pbInput []byte, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) = bcrypt.BCryptDecrypt
+//sys   SignHash (hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbInput []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) = bcrypt.BCryptSignHash
+//sys   VerifySignature(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbHash []byte, pbSignature []byte, dwFlags PadMode) (s error) = bcrypt.BCryptVerifySignature
+//sys   SecretAgreement(hPrivKey KEY_HANDLE, hPubKey KEY_HANDLE, phAgreedSecret *SECRET_HANDLE, dwFlags uint32) (s error) = bcrypt.BCryptSecretAgreement
+//sys   DeriveKey(hSharedSecret SECRET_HANDLE, pwszKDF *uint16, pParameterList *byte, pbDerivedKey []byte, pcbResult *uint32, dwFlags uint32) (s error) = bcrypt.BCryptDeriveKey
+//sys   DestroySecret(hSecret SECRET_HANDLE) (s error) = bcrypt.BCryptDestroySecret
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/zsyscall_windows.go b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/zsyscall_windows.go
new file mode 100644
index 00000000000000..53552169d7b980
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/bcrypt/zsyscall_windows.go
@@ -0,0 +1,380 @@
+// Code generated by 'go generate'; DO NOT EDIT.
+
+package bcrypt
+
+import (
+	"github.com/microsoft/go-crypto-winnative/internal/sysdll"
+	"syscall"
+	"unsafe"
+)
+
+var _ unsafe.Pointer
+
+// Do the interface allocations only once for common
+// Errno values.
+const (
+	errnoERROR_IO_PENDING = 997
+)
+
+var (
+	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
+	errERROR_EINVAL     error = syscall.EINVAL
+)
+
+// errnoErr returns common boxed Errno values, to prevent
+// allocations at runtime.
+func errnoErr(e syscall.Errno) error {
+	switch e {
+	case 0:
+		return errERROR_EINVAL
+	case errnoERROR_IO_PENDING:
+		return errERROR_IO_PENDING
+	}
+	// TODO: add more here, after collecting data on the common
+	// error values see on Windows. (perhaps when running
+	// all.bat?)
+	return e
+}
+
+var (
+	modbcrypt = syscall.NewLazyDLL(sysdll.Add("bcrypt.dll"))
+
+	procBCryptCloseAlgorithmProvider = modbcrypt.NewProc("BCryptCloseAlgorithmProvider")
+	procBCryptCreateHash             = modbcrypt.NewProc("BCryptCreateHash")
+	procBCryptDecrypt                = modbcrypt.NewProc("BCryptDecrypt")
+	procBCryptDeriveKey              = modbcrypt.NewProc("BCryptDeriveKey")
+	procBCryptDestroyHash            = modbcrypt.NewProc("BCryptDestroyHash")
+	procBCryptDestroyKey             = modbcrypt.NewProc("BCryptDestroyKey")
+	procBCryptDestroySecret          = modbcrypt.NewProc("BCryptDestroySecret")
+	procBCryptDuplicateHash          = modbcrypt.NewProc("BCryptDuplicateHash")
+	procBCryptEncrypt                = modbcrypt.NewProc("BCryptEncrypt")
+	procBCryptExportKey              = modbcrypt.NewProc("BCryptExportKey")
+	procBCryptFinalizeKeyPair        = modbcrypt.NewProc("BCryptFinalizeKeyPair")
+	procBCryptFinishHash             = modbcrypt.NewProc("BCryptFinishHash")
+	procBCryptGenRandom              = modbcrypt.NewProc("BCryptGenRandom")
+	procBCryptGenerateKeyPair        = modbcrypt.NewProc("BCryptGenerateKeyPair")
+	procBCryptGenerateSymmetricKey   = modbcrypt.NewProc("BCryptGenerateSymmetricKey")
+	procBCryptGetFipsAlgorithmMode   = modbcrypt.NewProc("BCryptGetFipsAlgorithmMode")
+	procBCryptGetProperty            = modbcrypt.NewProc("BCryptGetProperty")
+	procBCryptHash                   = modbcrypt.NewProc("BCryptHash")
+	procBCryptHashData               = modbcrypt.NewProc("BCryptHashData")
+	procBCryptImportKeyPair          = modbcrypt.NewProc("BCryptImportKeyPair")
+	procBCryptOpenAlgorithmProvider  = modbcrypt.NewProc("BCryptOpenAlgorithmProvider")
+	procBCryptSecretAgreement        = modbcrypt.NewProc("BCryptSecretAgreement")
+	procBCryptSetProperty            = modbcrypt.NewProc("BCryptSetProperty")
+	procBCryptSignHash               = modbcrypt.NewProc("BCryptSignHash")
+	procBCryptVerifySignature        = modbcrypt.NewProc("BCryptVerifySignature")
+)
+
+func CloseAlgorithmProvider(hAlgorithm ALG_HANDLE, dwFlags uint32) (s error) {
+	r0, _, _ := syscall.Syscall(procBCryptCloseAlgorithmProvider.Addr(), 2, uintptr(hAlgorithm), uintptr(dwFlags), 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func CreateHash(hAlgorithm ALG_HANDLE, phHash *HASH_HANDLE, pbHashObject []byte, pbSecret []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbHashObject) > 0 {
+		_p0 = &pbHashObject[0]
+	}
+	var _p1 *byte
+	if len(pbSecret) > 0 {
+		_p1 = &pbSecret[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptCreateHash.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func Decrypt(hKey KEY_HANDLE, pbInput []byte, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
+	var _p0 *byte
+	if len(pbInput) > 0 {
+		_p0 = &pbInput[0]
+	}
+	var _p1 *byte
+	if len(pbIV) > 0 {
+		_p1 = &pbIV[0]
+	}
+	var _p2 *byte
+	if len(pbOutput) > 0 {
+		_p2 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall12(procBCryptDecrypt.Addr(), 10, uintptr(hKey), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func DeriveKey(hSharedSecret SECRET_HANDLE, pwszKDF *uint16, pParameterList *byte, pbDerivedKey []byte, pcbResult *uint32, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbDerivedKey) > 0 {
+		_p0 = &pbDerivedKey[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptDeriveKey.Addr(), 7, uintptr(hSharedSecret), uintptr(unsafe.Pointer(pwszKDF)), uintptr(unsafe.Pointer(pParameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbDerivedKey)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func DestroyHash(hHash HASH_HANDLE) (s error) {
+	r0, _, _ := syscall.Syscall(procBCryptDestroyHash.Addr(), 1, uintptr(hHash), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func DestroyKey(hKey KEY_HANDLE) (s error) {
+	r0, _, _ := syscall.Syscall(procBCryptDestroyKey.Addr(), 1, uintptr(hKey), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func DestroySecret(hSecret SECRET_HANDLE) (s error) {
+	r0, _, _ := syscall.Syscall(procBCryptDestroySecret.Addr(), 1, uintptr(hSecret), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func DuplicateHash(hHash HASH_HANDLE, phNewHash *HASH_HANDLE, pbHashObject []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbHashObject) > 0 {
+		_p0 = &pbHashObject[0]
+	}
+	r0, _, _ := syscall.Syscall6(procBCryptDuplicateHash.Addr(), 5, uintptr(hHash), uintptr(unsafe.Pointer(phNewHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHashObject)), uintptr(dwFlags), 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func _Encrypt(hKey KEY_HANDLE, pbInput *byte, cbInput uint32, pPaddingInfo unsafe.Pointer, pbIV []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
+	var _p0 *byte
+	if len(pbIV) > 0 {
+		_p0 = &pbIV[0]
+	}
+	var _p1 *byte
+	if len(pbOutput) > 0 {
+		_p1 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall12(procBCryptEncrypt.Addr(), 10, uintptr(hKey), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbIV)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func ExportKey(hKey KEY_HANDLE, hExportKey KEY_HANDLE, pszBlobType *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbOutput) > 0 {
+		_p0 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptExportKey.Addr(), 7, uintptr(hKey), uintptr(hExportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func FinalizeKeyPair(hKey KEY_HANDLE, dwFlags uint32) (s error) {
+	r0, _, _ := syscall.Syscall(procBCryptFinalizeKeyPair.Addr(), 2, uintptr(hKey), uintptr(dwFlags), 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func FinishHash(hHash HASH_HANDLE, pbOutput []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbOutput) > 0 {
+		_p0 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall6(procBCryptFinishHash.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func GenRandom(hAlgorithm ALG_HANDLE, pbBuffer []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbBuffer) > 0 {
+		_p0 = &pbBuffer[0]
+	}
+	r0, _, _ := syscall.Syscall6(procBCryptGenRandom.Addr(), 4, uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbBuffer)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func GenerateKeyPair(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, dwLength uint32, dwFlags uint32) (s error) {
+	r0, _, _ := syscall.Syscall6(procBCryptGenerateKeyPair.Addr(), 4, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(dwLength), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func GenerateSymmetricKey(hAlgorithm ALG_HANDLE, phKey *KEY_HANDLE, pbKeyObject []byte, pbSecret []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbKeyObject) > 0 {
+		_p0 = &pbKeyObject[0]
+	}
+	var _p1 *byte
+	if len(pbSecret) > 0 {
+		_p1 = &pbSecret[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptGenerateSymmetricKey.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbKeyObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSecret)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func GetFipsAlgorithmMode(enabled *bool) (s error) {
+	var _p0 uint32
+	if *enabled {
+		_p0 = 1
+	}
+	r0, _, _ := syscall.Syscall(procBCryptGetFipsAlgorithmMode.Addr(), 1, uintptr(unsafe.Pointer(&_p0)), 0, 0)
+	*enabled = _p0 != 0
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func GetProperty(hObject HANDLE, pszProperty *uint16, pbOutput []byte, pcbResult *uint32, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbOutput) > 0 {
+		_p0 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall6(procBCryptGetProperty.Addr(), 6, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags))
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func Hash(hAlgorithm ALG_HANDLE, pbSecret []byte, pbInput []byte, pbOutput []byte) (s error) {
+	var _p0 *byte
+	if len(pbSecret) > 0 {
+		_p0 = &pbSecret[0]
+	}
+	var _p1 *byte
+	if len(pbInput) > 0 {
+		_p1 = &pbInput[0]
+	}
+	var _p2 *byte
+	if len(pbOutput) > 0 {
+		_p2 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptHash.Addr(), 7, uintptr(hAlgorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbSecret)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(_p2)), uintptr(len(pbOutput)), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func HashDataRaw(hHash HASH_HANDLE, pbInput *byte, cbInput uint32, dwFlags uint32) (s error) {
+	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(pbInput)), uintptr(cbInput), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func HashData(hHash HASH_HANDLE, pbInput []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbInput) > 0 {
+		_p0 = &pbInput[0]
+	}
+	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hHash), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func ImportKeyPair(hAlgorithm ALG_HANDLE, hImportKey KEY_HANDLE, pszBlobType *uint16, phKey *KEY_HANDLE, pbInput []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbInput) > 0 {
+		_p0 = &pbInput[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptImportKeyPair.Addr(), 7, uintptr(hAlgorithm), uintptr(hImportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(phKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func OpenAlgorithmProvider(phAlgorithm *ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, dwFlags AlgorithmProviderFlags) (s error) {
+	r0, _, _ := syscall.Syscall6(procBCryptOpenAlgorithmProvider.Addr(), 4, uintptr(unsafe.Pointer(phAlgorithm)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszImplementation)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func SecretAgreement(hPrivKey KEY_HANDLE, hPubKey KEY_HANDLE, phAgreedSecret *SECRET_HANDLE, dwFlags uint32) (s error) {
+	r0, _, _ := syscall.Syscall6(procBCryptSecretAgreement.Addr(), 4, uintptr(hPrivKey), uintptr(hPubKey), uintptr(unsafe.Pointer(phAgreedSecret)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func SetProperty(hObject HANDLE, pszProperty *uint16, pbInput []byte, dwFlags uint32) (s error) {
+	var _p0 *byte
+	if len(pbInput) > 0 {
+		_p0 = &pbInput[0]
+	}
+	r0, _, _ := syscall.Syscall6(procBCryptSetProperty.Addr(), 5, uintptr(hObject), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(dwFlags), 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func SignHash(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbInput []byte, pbOutput []byte, pcbResult *uint32, dwFlags PadMode) (s error) {
+	var _p0 *byte
+	if len(pbInput) > 0 {
+		_p0 = &pbInput[0]
+	}
+	var _p1 *byte
+	if len(pbOutput) > 0 {
+		_p1 = &pbOutput[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptSignHash.Addr(), 8, uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbInput)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbOutput)), uintptr(unsafe.Pointer(pcbResult)), uintptr(dwFlags), 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
+
+func VerifySignature(hKey KEY_HANDLE, pPaddingInfo unsafe.Pointer, pbHash []byte, pbSignature []byte, dwFlags PadMode) (s error) {
+	var _p0 *byte
+	if len(pbHash) > 0 {
+		_p0 = &pbHash[0]
+	}
+	var _p1 *byte
+	if len(pbSignature) > 0 {
+		_p1 = &pbSignature[0]
+	}
+	r0, _, _ := syscall.Syscall9(procBCryptVerifySignature.Addr(), 7, uintptr(hKey), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbHash)), uintptr(unsafe.Pointer(_p1)), uintptr(len(pbSignature)), uintptr(dwFlags), 0, 0)
+	if r0 != 0 {
+		s = syscall.Errno(r0)
+	}
+	return
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/internal/subtle/aliasing.go b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/subtle/aliasing.go
new file mode 100644
index 00000000000000..db09e4aae64f8c
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/subtle/aliasing.go
@@ -0,0 +1,32 @@
+// Copyright 2018 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package subtle implements functions that are often useful in cryptographic
+// code but require careful thought to use correctly.
+//
+// This is a mirror of golang.org/x/crypto/internal/subtle.
+package subtle
+
+import "unsafe"
+
+// AnyOverlap reports whether x and y share memory at any (not necessarily
+// corresponding) index. The memory beyond the slice length is ignored.
+func AnyOverlap(x, y []byte) bool {
+	return len(x) > 0 && len(y) > 0 &&
+		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
+		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
+}
+
+// InexactOverlap reports whether x and y share memory at any non-corresponding
+// index. The memory beyond the slice length is ignored. Note that x and y can
+// have different lengths and still not have any inexact overlap.
+//
+// InexactOverlap can be used to implement the requirements of the crypto/cipher
+// AEAD, Block, BlockMode and Stream interfaces.
+func InexactOverlap(x, y []byte) bool {
+	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
+		return false
+	}
+	return AnyOverlap(x, y)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-winnative/internal/sysdll/sys_windows.go b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/sysdll/sys_windows.go
new file mode 100644
index 00000000000000..1722410e5af193
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-winnative/internal/sysdll/sys_windows.go
@@ -0,0 +1,55 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+// Package sysdll is a custom version of the standard library internal/syscall/windows/sysdll package.
+// sysdll is used to guard against Windows DLL preloading attacks.
+// We can't call Go's sysdll.Add function from within go-crypto-winnative because sysdll is an internal package,
+// so we have reimplemented the sysdll.Add function in a way that it always returns
+// DLL absolute paths rooted at the system directory.
+// See go.dev/issues/14959 for more info.
+package sysdll
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+var (
+	// kernel32.dll is a known system DLL used by Go,
+	// so protected against DLL preloading attacks.
+	modkernel32             = syscall.NewLazyDLL("kernel32.dll")
+	procGetSystemDirectoryW = modkernel32.NewProc("GetSystemDirectoryW")
+)
+
+func getSystemDirectoryW(dir *uint16, dirLen uint32) (len uint32, err error) {
+	r0, _, e1 := syscall.Syscall(procGetSystemDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
+	len = uint32(r0)
+	if len == 0 {
+		err = e1
+	}
+	return
+}
+
+// getSystemDirectory retrieves the path to current location of the system
+// directory, which is typically, though not always, `C:\Windows\System32`.
+func getSystemDirectory() string {
+	n := uint32(syscall.MAX_PATH)
+	for {
+		b := make([]uint16, n)
+		l, e := getSystemDirectoryW(&b[0], n)
+		if e != nil {
+			panic(e)
+		}
+		if l <= n {
+			return syscall.UTF16ToString(b[:l])
+		}
+		n = l
+	}
+}
+
+// Add returns the absolute path of the dll.
+// The returned path points to the system directory,
+// so it is secure against DLL preloading attacks.
+func Add(dll string) string {
+	return getSystemDirectory() + "\\" + dll
+}
diff --git a/src/vendor/modules.txt b/src/vendor/modules.txt
index 438c2f447be441..6f2e303cc5f53c 100644
--- a/src/vendor/modules.txt
+++ b/src/vendor/modules.txt
@@ -1,3 +1,15 @@
+# github.com/microsoft/go-crypto-openssl v0.2.7
+## explicit; go 1.17
+github.com/microsoft/go-crypto-openssl/openssl
+github.com/microsoft/go-crypto-openssl/openssl/bbig
+github.com/microsoft/go-crypto-openssl/openssl/internal/subtle
+# github.com/microsoft/go-crypto-winnative v0.0.0-20230502061212-6eb98854418e
+## explicit; go 1.17
+github.com/microsoft/go-crypto-winnative/cng
+github.com/microsoft/go-crypto-winnative/cng/bbig
+github.com/microsoft/go-crypto-winnative/internal/bcrypt
+github.com/microsoft/go-crypto-winnative/internal/subtle
+github.com/microsoft/go-crypto-winnative/internal/sysdll
 # golang.org/x/crypto v0.11.1-0.20230711161743-2e82bdd1719d
 ## explicit; go 1.17
 golang.org/x/crypto/chacha20
